// This file is auto-generated by @hey-api/openapi-ts

export type SiteConfig = {
  /**
   * The Matrix server name for which this instance is configured
   */
  server_name: string;
  /**
   * Whether password login is enabled.
   */
  password_login_enabled: boolean;
  /**
   * Whether password registration is enabled.
   */
  password_registration_enabled: boolean;
  /**
   * Whether registration tokens are required for password registrations.
   */
  registration_token_required: boolean;
  /**
   * Whether users can change their email.
   */
  email_change_allowed: boolean;
  /**
   * Whether users can change their display name.
   */
  displayname_change_allowed: boolean;
  /**
   * Whether users can change their password.
   */
  password_change_allowed: boolean;
  /**
   * Whether users can recover their account via email.
   */
  account_recovery_allowed: boolean;
  /**
   * Whether users can delete their own account.
   */
  account_deactivation_allowed: boolean;
  /**
   * Whether CAPTCHA during registration is enabled.
   */
  captcha_enabled: boolean;
  /**
   * Minimum password complexity, between 0 and 4. This is a score from zxcvbn.
   */
  minimum_password_complexity: number;
};

export type PaginationParams = {
  "page[before]"?: Ulid;
  "page[after]"?: Ulid;
  /**
   * Retrieve the first N items
   */
  "page[first]"?: number | null;
  /**
   * Retrieve the last N items
   */
  "page[last]"?: number | null;
};

/**
 * ULID
 * A ULID as per https://github.com/ulid/spec
 */
export type Ulid = string;

export type CompatSessionFilter = {
  "filter[user]"?: Ulid;
  "filter[user-session]"?: Ulid;
  "filter[status]"?: CompatSessionStatus;
};

export type CompatSessionStatus = "active" | "finished";

/**
 * A top-level response with a page of resources
 */
export type PaginatedResponseForCompatSession = {
  meta: PaginationMeta;
  /**
   * The list of resources
   */
  data: Array<SingleResourceForCompatSession>;
  links: PaginationLinks;
};

export type PaginationMeta = {
  /**
   * The total number of results
   */
  count: number;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForCompatSession = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: CompatSession;
  links: SelfLinks;
};

/**
 * A compatibility session for legacy clients
 */
export type CompatSession = {
  user_id: Ulid;
  device_id: DeviceId;
  user_session_id: Ulid;
  /**
   * The redirect URI used to login in the client, if it was an SSO login
   */
  redirect_uri?: string | null;
  /**
   * The time this session was created
   */
  created_at: string;
  /**
   * The user agent string that started this session, if any
   */
  user_agent?: string | null;
  /**
   * The time this session was last active
   */
  last_active_at?: string | null;
  /**
   * The last IP address recorded for this session
   */
  last_active_ip?: string | null;
  /**
   * The time this session was finished
   */
  finished_at?: string | null;
  /**
   * The user-provided name, if any
   */
  human_name?: string | null;
};

/**
 * Device ID
 */
export type DeviceId = string;

/**
 * Related links
 */
export type SelfLinks = {
  /**
   * The canonical link to the current resource
   */
  self: string;
};

/**
 * Related links
 */
export type PaginationLinks = {
  /**
   * The canonical link to the current page
   */
  self: string;
  /**
   * The link to the first page of results
   */
  first: string;
  /**
   * The link to the last page of results
   */
  last: string;
  /**
   * The link to the next page of results
   *
   * Only present if there is a next page
   */
  next?: string | null;
  /**
   * The link to the previous page of results
   *
   * Only present if there is a previous page
   */
  prev?: string | null;
};

/**
 * A top-level response with a list of errors
 */
export type ErrorResponse = {
  /**
   * The list of errors
   */
  errors: Array<_Error>;
};

/**
 * A single error
 */
export type _Error = {
  /**
   * A human-readable title for the error
   */
  title: string;
};

export type UlidInPath = {
  id: Ulid;
};

/**
 * A top-level response with a single resource
 */
export type SingleResponseForCompatSession = {
  data: SingleResourceForCompatSession;
  links: SelfLinks;
};

export type OAuth2SessionFilter = {
  "filter[user]"?: Ulid;
  "filter[client]"?: Ulid;
  "filter[client-kind]"?: OAuth2ClientKind;
  "filter[user-session]"?: Ulid;
  /**
   * Retrieve the items with the given scope
   */
  "filter[scope]"?: Array<string>;
  "filter[status]"?: OAuth2SessionStatus;
};

export type OAuth2ClientKind = "dynamic" | "static";

export type OAuth2SessionStatus = "active" | "finished";

/**
 * A top-level response with a page of resources
 */
export type PaginatedResponseForOAuth2Session = {
  meta: PaginationMeta;
  /**
   * The list of resources
   */
  data: Array<SingleResourceForOAuth2Session>;
  links: PaginationLinks;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForOAuth2Session = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: OAuth2Session;
  links: SelfLinks;
};

/**
 * A OAuth 2.0 session
 */
export type OAuth2Session = {
  /**
   * When the object was created
   */
  created_at: string;
  /**
   * When the session was finished
   */
  finished_at?: string | null;
  user_id?: Ulid;
  user_session_id?: Ulid;
  client_id: Ulid;
  /**
   * The scope granted for this session
   */
  scope: string;
  /**
   * The user agent string of the client which started this session
   */
  user_agent?: string | null;
  /**
   * The last time the session was active
   */
  last_active_at?: string | null;
  /**
   * The last IP address used by the session
   */
  last_active_ip?: string | null;
  /**
   * The user-provided name, if any
   */
  human_name?: string | null;
};

/**
 * A top-level response with a single resource
 */
export type SingleResponseForOAuth2Session = {
  data: SingleResourceForOAuth2Session;
  links: SelfLinks;
};

/**
 * JSON payload for the `POST /api/admin/v1/policy-data`
 */
export type SetPolicyDataRequest = {
  data: unknown;
};

/**
 * A top-level response with a single resource
 */
export type SingleResponseForPolicyData = {
  data: SingleResourceForPolicyData;
  links: SelfLinks;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForPolicyData = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: PolicyData;
  links: SelfLinks;
};

/**
 * The policy data
 */
export type PolicyData = {
  /**
   * The creation date of the policy data
   */
  created_at: string;
  /**
   * The policy data content
   */
  data: unknown;
};

export type UserFilter = {
  /**
   * Retrieve users with (or without) the `admin` flag set
   */
  "filter[admin]"?: boolean | null;
  /**
   * Retrieve users with (or without) the `legacy_guest` flag set
   */
  "filter[legacy-guest]"?: boolean | null;
  /**
   * Retrieve users where the username matches contains the given string
   *
   * Note that this doesn't change the ordering of the result, which are still ordered by ID.
   */
  "filter[search]"?: string | null;
  "filter[status]"?: UserStatus;
};

export type UserStatus = "active" | "locked" | "deactivated";

/**
 * A top-level response with a page of resources
 */
export type PaginatedResponseForUser = {
  meta: PaginationMeta;
  /**
   * The list of resources
   */
  data: Array<SingleResourceForUser>;
  links: PaginationLinks;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForUser = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: User;
  links: SelfLinks;
};

/**
 * A user
 */
export type User = {
  /**
   * The username (localpart) of the user
   */
  username: string;
  /**
   * When the user was created
   */
  created_at: string;
  /**
   * When the user was locked. If null, the user is not locked.
   */
  locked_at?: string | null;
  /**
   * When the user was deactivated. If null, the user is not deactivated.
   */
  deactivated_at?: string | null;
  /**
   * Whether the user can request admin privileges.
   */
  admin: boolean;
  /**
   * Whether the user was a guest before migrating to MAS,
   */
  legacy_guest?: boolean;
};

/**
 * JSON payload for the `POST /api/admin/v1/users` endpoint
 */
export type AddUserRequest = {
  /**
   * The username of the user to add.
   */
  username: string;
  /**
   * Skip checking with the homeserver whether the username is available.
   *
   * Use this with caution! The main reason to use this, is when a user used by an application service needs to exist in MAS to craft special tokens (like with admin access) for them
   */
  skip_homeserver_check?: boolean;
};

/**
 * A top-level response with a single resource
 */
export type SingleResponseForUser = {
  data: SingleResourceForUser;
  links: SelfLinks;
};

/**
 * JSON payload for the `POST /api/admin/v1/users/:id/set-password` endpoint
 */
export type SetUserPasswordRequest = {
  /**
   * The password to set for the user
   */
  password: string;
  /**
   * Skip the password complexity check
   */
  skip_password_check?: boolean | null;
};

export type UsernamePathParam = {
  /**
   * The username (localpart) of the user to get
   */
  username: string;
};

/**
 * JSON payload for the `POST /api/admin/v1/users/:id/set-admin` endpoint
 */
export type UserSetAdminRequest = {
  /**
   * Whether the user can request admin privileges.
   */
  admin: boolean;
};

/**
 * JSON payload for the `POST /api/admin/v1/users/:id/deactivate` endpoint
 */
export type DeactivateUserRequest = {
  /**
   * Whether to skip requesting the homeserver to GDPR-erase the user upon deactivation.
   */
  skip_erase?: boolean;
};

export type UserEmailFilter = {
  "filter[user]"?: Ulid;
  /**
   * Retrieve the user email with the given email address
   */
  "filter[email]"?: string | null;
};

/**
 * A top-level response with a page of resources
 */
export type PaginatedResponseForUserEmail = {
  meta: PaginationMeta;
  /**
   * The list of resources
   */
  data: Array<SingleResourceForUserEmail>;
  links: PaginationLinks;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForUserEmail = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: UserEmail;
  links: SelfLinks;
};

/**
 * An email address for a user
 */
export type UserEmail = {
  /**
   * When the object was created
   */
  created_at: string;
  user_id: Ulid;
  /**
   * The email address
   */
  email: string;
};

/**
 * JSON payload for the `POST /api/admin/v1/user-emails`
 */
export type AddUserEmailRequest = {
  user_id: Ulid;
  /**
   * The email address of the user to add.
   */
  email: string;
};

/**
 * A top-level response with a single resource
 */
export type SingleResponseForUserEmail = {
  data: SingleResourceForUserEmail;
  links: SelfLinks;
};

export type UserSessionFilter = {
  "filter[user]"?: Ulid;
  "filter[status]"?: UserSessionStatus;
};

export type UserSessionStatus = "active" | "finished";

/**
 * A top-level response with a page of resources
 */
export type PaginatedResponseForUserSession = {
  meta: PaginationMeta;
  /**
   * The list of resources
   */
  data: Array<SingleResourceForUserSession>;
  links: PaginationLinks;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForUserSession = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: UserSession;
  links: SelfLinks;
};

/**
 * The browser (cookie) session for a user
 */
export type UserSession = {
  /**
   * When the object was created
   */
  created_at: string;
  /**
   * When the session was finished
   */
  finished_at?: string | null;
  user_id: Ulid;
  /**
   * The user agent string of the client which started this session
   */
  user_agent?: string | null;
  /**
   * The last time the session was active
   */
  last_active_at?: string | null;
  /**
   * The last IP address used by the session
   */
  last_active_ip?: string | null;
};

/**
 * A top-level response with a single resource
 */
export type SingleResponseForUserSession = {
  data: SingleResourceForUserSession;
  links: SelfLinks;
};

export type RegistrationTokenFilter = {
  /**
   * Retrieve tokens that have (or have not) been used at least once
   */
  "filter[used]"?: boolean | null;
  /**
   * Retrieve tokens that are (or are not) revoked
   */
  "filter[revoked]"?: boolean | null;
  /**
   * Retrieve tokens that are (or are not) expired
   */
  "filter[expired]"?: boolean | null;
  /**
   * Retrieve tokens that are (or are not) valid
   *
   * Valid means that the token has not expired, is not revoked, and has not reached its usage limit.
   */
  "filter[valid]"?: boolean | null;
};

/**
 * A top-level response with a page of resources
 */
export type PaginatedResponseForUserRegistrationToken = {
  meta: PaginationMeta;
  /**
   * The list of resources
   */
  data: Array<SingleResourceForUserRegistrationToken>;
  links: PaginationLinks;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForUserRegistrationToken = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: UserRegistrationToken;
  links: SelfLinks;
};

/**
 * A registration token
 */
export type UserRegistrationToken = {
  /**
   * The token string
   */
  token: string;
  /**
   * Whether the token is valid
   */
  valid: boolean;
  /**
   * Maximum number of times this token can be used
   */
  usage_limit?: number | null;
  /**
   * Number of times this token has been used
   */
  times_used: number;
  /**
   * When the token was created
   */
  created_at: string;
  /**
   * When the token was last used. If null, the token has never been used.
   */
  last_used_at?: string | null;
  /**
   * When the token expires. If null, the token never expires.
   */
  expires_at?: string | null;
  /**
   * When the token was revoked. If null, the token is not revoked.
   */
  revoked_at?: string | null;
};

/**
 * JSON payload for the `POST /api/admin/v1/user-registration-tokens`
 */
export type AddUserRegistrationTokenRequest = {
  /**
   * The token string. If not provided, a random token will be generated.
   */
  token?: string | null;
  /**
   * Maximum number of times this token can be used. If not provided, the token can be used an unlimited number of times.
   */
  usage_limit?: number | null;
  /**
   * When the token expires. If not provided, the token never expires.
   */
  expires_at?: string | null;
};

/**
 * A top-level response with a single resource
 */
export type SingleResponseForUserRegistrationToken = {
  data: SingleResourceForUserRegistrationToken;
  links: SelfLinks;
};

/**
 * JSON payload for the `PUT /api/admin/v1/user-registration-tokens/{id}` endpoint
 */
export type EditUserRegistrationTokenRequest = {
  /**
   * New expiration date for the token, or null to remove expiration
   */
  expires_at?: string | null;
  /**
   * New usage limit for the token, or null to remove the limit
   */
  usage_limit?: number | null;
};

export type UpstreamOAuthLinkFilter = {
  "filter[user]"?: Ulid;
  "filter[provider]"?: Ulid;
  /**
   * Retrieve the items with the given subject
   */
  "filter[subject]"?: string | null;
};

/**
 * A top-level response with a page of resources
 */
export type PaginatedResponseForUpstreamOAuthLink = {
  meta: PaginationMeta;
  /**
   * The list of resources
   */
  data: Array<SingleResourceForUpstreamOAuthLink>;
  links: PaginationLinks;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForUpstreamOAuthLink = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: UpstreamOAuthLink;
  links: SelfLinks;
};

/**
 * An upstream OAuth 2.0 link
 */
export type UpstreamOAuthLink = {
  /**
   * When the object was created
   */
  created_at: string;
  provider_id: Ulid;
  /**
   * The subject of the upstream account, unique per provider
   */
  subject: string;
  user_id?: Ulid;
  /**
   * A human-readable name of the upstream account
   */
  human_account_name?: string | null;
};

/**
 * JSON payload for the `POST /api/admin/v1/upstream-oauth-links`
 */
export type AddUpstreamOauthLinkRequest = {
  user_id: Ulid;
  provider_id: Ulid;
  /**
   * The subject (sub) claim of the user on the provider.
   */
  subject: string;
  /**
   * A human readable account name.
   */
  human_account_name?: string | null;
};

/**
 * A top-level response with a single resource
 */
export type SingleResponseForUpstreamOAuthLink = {
  data: SingleResourceForUpstreamOAuthLink;
  links: SelfLinks;
};

export type UpstreamOAuthProviderFilter = {
  /**
   * Retrieve providers that are (or are not) enabled
   */
  "filter[enabled]"?: boolean | null;
};

/**
 * A top-level response with a page of resources
 */
export type PaginatedResponseForUpstreamOAuthProvider = {
  meta: PaginationMeta;
  /**
   * The list of resources
   */
  data: Array<SingleResourceForUpstreamOAuthProvider>;
  links: PaginationLinks;
};

/**
 * A single resource, with its type, ID, attributes and related links
 */
export type SingleResourceForUpstreamOAuthProvider = {
  /**
   * The type of the resource
   */
  type: string;
  id: Ulid;
  attributes: UpstreamOAuthProvider;
  links: SelfLinks;
};

/**
 * An upstream OAuth 2.0 provider
 */
export type UpstreamOAuthProvider = {
  /**
   * The OIDC issuer of the provider
   */
  issuer?: string | null;
  /**
   * A human-readable name for the provider
   */
  human_name?: string | null;
  /**
   * A brand identifier, e.g. "apple" or "google"
   */
  brand_name?: string | null;
  /**
   * When the provider was created
   */
  created_at: string;
  /**
   * When the provider was disabled. If null, the provider is enabled.
   */
  disabled_at?: string | null;
};

export type SiteConfigData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/admin/v1/site-config";
};

export type SiteConfigResponses = {
  200: SiteConfig;
};

export type SiteConfigResponse = SiteConfigResponses[keyof SiteConfigResponses];

export type ListCompatSessionsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Retrieve the items before the given ID
     */
    "page[before]"?: Ulid;
    /**
     * Retrieve the items after the given ID
     */
    "page[after]"?: Ulid;
    /**
     * Retrieve the first N items
     */
    "page[first]"?: number | null;
    /**
     * Retrieve the last N items
     */
    "page[last]"?: number | null;
    /**
     * Retrieve the items for the given user
     */
    "filter[user]"?: Ulid;
    /**
     * Retrieve the items started from the given browser session
     */
    "filter[user-session]"?: Ulid;
    /**
     * Retrieve the items with the given status
     *
     * Defaults to retrieve all sessions, including finished ones.
     *
     * * `active`: Only retrieve active sessions
     *
     * * `finished`: Only retrieve finished sessions
     */
    "filter[status]"?: CompatSessionStatus;
  };
  url: "/api/admin/v1/compat-sessions";
};

export type ListCompatSessionsErrors = {
  /**
   * User was not found
   */
  404: ErrorResponse;
};

export type ListCompatSessionsError =
  ListCompatSessionsErrors[keyof ListCompatSessionsErrors];

export type ListCompatSessionsResponses = {
  /**
   * Paginated response of compatibility sessions
   */
  200: PaginatedResponseForCompatSession;
};

export type ListCompatSessionsResponse =
  ListCompatSessionsResponses[keyof ListCompatSessionsResponses];

export type GetCompatSessionData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/compat-sessions/{id}";
};

export type GetCompatSessionErrors = {
  /**
   * Compatibility session was not found
   */
  404: ErrorResponse;
};

export type GetCompatSessionError =
  GetCompatSessionErrors[keyof GetCompatSessionErrors];

export type GetCompatSessionResponses = {
  /**
   * Compatibility session was found
   */
  200: SingleResponseForCompatSession;
};

export type GetCompatSessionResponse =
  GetCompatSessionResponses[keyof GetCompatSessionResponses];

export type ListOAuth2SessionsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Retrieve the items before the given ID
     */
    "page[before]"?: Ulid;
    /**
     * Retrieve the items after the given ID
     */
    "page[after]"?: Ulid;
    /**
     * Retrieve the first N items
     */
    "page[first]"?: number | null;
    /**
     * Retrieve the last N items
     */
    "page[last]"?: number | null;
    /**
     * Retrieve the items for the given user
     */
    "filter[user]"?: Ulid;
    /**
     * Retrieve the items for the given client
     */
    "filter[client]"?: Ulid;
    /**
     * Retrieve the items only for a specific client kind
     */
    "filter[client-kind]"?: OAuth2ClientKind;
    /**
     * Retrieve the items started from the given browser session
     */
    "filter[user-session]"?: Ulid;
    /**
     * Retrieve the items with the given scope
     */
    "filter[scope]"?: Array<string>;
    /**
     * Retrieve the items with the given status
     *
     * Defaults to retrieve all sessions, including finished ones.
     *
     * * `active`: Only retrieve active sessions
     *
     * * `finished`: Only retrieve finished sessions
     */
    "filter[status]"?: OAuth2SessionStatus;
  };
  url: "/api/admin/v1/oauth2-sessions";
};

export type ListOAuth2SessionsErrors = {
  /**
   * Invalid scope
   */
  400: ErrorResponse;
  /**
   * User was not found
   */
  404: ErrorResponse;
};

export type ListOAuth2SessionsError =
  ListOAuth2SessionsErrors[keyof ListOAuth2SessionsErrors];

export type ListOAuth2SessionsResponses = {
  /**
   * Paginated response of OAuth 2.0 sessions
   */
  200: PaginatedResponseForOAuth2Session;
};

export type ListOAuth2SessionsResponse =
  ListOAuth2SessionsResponses[keyof ListOAuth2SessionsResponses];

export type GetOAuth2SessionData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/oauth2-sessions/{id}";
};

export type GetOAuth2SessionErrors = {
  /**
   * OAuth 2.0 session was not found
   */
  404: ErrorResponse;
};

export type GetOAuth2SessionError =
  GetOAuth2SessionErrors[keyof GetOAuth2SessionErrors];

export type GetOAuth2SessionResponses = {
  /**
   * OAuth 2.0 session was found
   */
  200: SingleResponseForOAuth2Session;
};

export type GetOAuth2SessionResponse =
  GetOAuth2SessionResponses[keyof GetOAuth2SessionResponses];

export type SetPolicyDataData = {
  body: SetPolicyDataRequest;
  path?: never;
  query?: never;
  url: "/api/admin/v1/policy-data";
};

export type SetPolicyDataErrors = {
  /**
   * Invalid policy data
   */
  400: ErrorResponse;
};

export type SetPolicyDataError = SetPolicyDataErrors[keyof SetPolicyDataErrors];

export type SetPolicyDataResponses = {
  /**
   * Policy data was successfully set
   */
  201: SingleResponseForPolicyData;
};

export type SetPolicyDataResponse =
  SetPolicyDataResponses[keyof SetPolicyDataResponses];

export type GetLatestPolicyDataData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/admin/v1/policy-data/latest";
};

export type GetLatestPolicyDataErrors = {
  /**
   * No policy data was found
   */
  404: ErrorResponse;
};

export type GetLatestPolicyDataError =
  GetLatestPolicyDataErrors[keyof GetLatestPolicyDataErrors];

export type GetLatestPolicyDataResponses = {
  /**
   * Latest policy data was found
   */
  200: SingleResponseForPolicyData;
};

export type GetLatestPolicyDataResponse =
  GetLatestPolicyDataResponses[keyof GetLatestPolicyDataResponses];

export type GetPolicyDataData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/policy-data/{id}";
};

export type GetPolicyDataErrors = {
  /**
   * Policy data was not found
   */
  404: ErrorResponse;
};

export type GetPolicyDataError = GetPolicyDataErrors[keyof GetPolicyDataErrors];

export type GetPolicyDataResponses = {
  /**
   * Policy data was found
   */
  200: SingleResponseForPolicyData;
};

export type GetPolicyDataResponse =
  GetPolicyDataResponses[keyof GetPolicyDataResponses];

export type ListUsersData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Retrieve the items before the given ID
     */
    "page[before]"?: Ulid;
    /**
     * Retrieve the items after the given ID
     */
    "page[after]"?: Ulid;
    /**
     * Retrieve the first N items
     */
    "page[first]"?: number | null;
    /**
     * Retrieve the last N items
     */
    "page[last]"?: number | null;
    /**
     * Retrieve users with (or without) the `admin` flag set
     */
    "filter[admin]"?: boolean | null;
    /**
     * Retrieve users with (or without) the `legacy_guest` flag set
     */
    "filter[legacy-guest]"?: boolean | null;
    /**
     * Retrieve users where the username matches contains the given string
     *
     * Note that this doesn't change the ordering of the result, which are still ordered by ID.
     */
    "filter[search]"?: string | null;
    /**
     * Retrieve the items with the given status
     *
     * Defaults to retrieve all users, including locked ones.
     *
     * * `active`: Only retrieve active users
     *
     * * `locked`: Only retrieve locked users (includes deactivated users)
     *
     * * `deactivated`: Only retrieve deactivated users
     */
    "filter[status]"?: UserStatus;
  };
  url: "/api/admin/v1/users";
};

export type ListUsersResponses = {
  /**
   * Paginated response of users
   */
  200: PaginatedResponseForUser;
};

export type ListUsersResponse = ListUsersResponses[keyof ListUsersResponses];

export type CreateUserData = {
  body: AddUserRequest;
  path?: never;
  query?: never;
  url: "/api/admin/v1/users";
};

export type CreateUserErrors = {
  /**
   * Username is not valid
   */
  400: ErrorResponse;
  /**
   * Username is reserved by the homeserver
   */
  409: ErrorResponse;
};

export type CreateUserError = CreateUserErrors[keyof CreateUserErrors];

export type CreateUserResponses = {
  /**
   * User was created
   */
  201: SingleResponseForUser;
};

export type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];

export type GetUserData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/users/{id}";
};

export type GetUserErrors = {
  /**
   * User was not found
   */
  404: ErrorResponse;
};

export type GetUserError = GetUserErrors[keyof GetUserErrors];

export type GetUserResponses = {
  /**
   * User was found
   */
  200: SingleResponseForUser;
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type SetUserPasswordData = {
  body: SetUserPasswordRequest;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/users/{id}/set-password";
};

export type SetUserPasswordErrors = {
  /**
   * Password is too weak
   */
  400: ErrorResponse;
  /**
   * Password auth is disabled in the server configuration
   */
  403: ErrorResponse;
  /**
   * User was not found
   */
  404: ErrorResponse;
};

export type SetUserPasswordError =
  SetUserPasswordErrors[keyof SetUserPasswordErrors];

export type SetUserPasswordResponses = {
  /**
   * Password was set
   */
  204: void;
};

export type SetUserPasswordResponse =
  SetUserPasswordResponses[keyof SetUserPasswordResponses];

export type GetUserByUsernameData = {
  body?: never;
  path: {
    /**
     * The username (localpart) of the user to get
     */
    username: string;
  };
  query?: never;
  url: "/api/admin/v1/users/by-username/{username}";
};

export type GetUserByUsernameErrors = {
  /**
   * User was not found
   */
  404: ErrorResponse;
};

export type GetUserByUsernameError =
  GetUserByUsernameErrors[keyof GetUserByUsernameErrors];

export type GetUserByUsernameResponses = {
  /**
   * User was found
   */
  200: SingleResponseForUser;
};

export type GetUserByUsernameResponse =
  GetUserByUsernameResponses[keyof GetUserByUsernameResponses];

export type UserSetAdminData = {
  body: UserSetAdminRequest;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/users/{id}/set-admin";
};

export type UserSetAdminErrors = {
  /**
   * User ID not found
   */
  404: ErrorResponse;
};

export type UserSetAdminError = UserSetAdminErrors[keyof UserSetAdminErrors];

export type UserSetAdminResponses = {
  /**
   * User had admin privileges set
   */
  200: SingleResponseForUser;
};

export type UserSetAdminResponse =
  UserSetAdminResponses[keyof UserSetAdminResponses];

export type DeactivateUserData = {
  body?: DeactivateUserRequest;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/users/{id}/deactivate";
};

export type DeactivateUserErrors = {
  /**
   * User ID not found
   */
  404: ErrorResponse;
};

export type DeactivateUserError =
  DeactivateUserErrors[keyof DeactivateUserErrors];

export type DeactivateUserResponses = {
  /**
   * User was deactivated
   */
  200: SingleResponseForUser;
};

export type DeactivateUserResponse =
  DeactivateUserResponses[keyof DeactivateUserResponses];

export type ReactivateUserData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/users/{id}/reactivate";
};

export type ReactivateUserErrors = {
  /**
   * User ID not found
   */
  404: ErrorResponse;
};

export type ReactivateUserError =
  ReactivateUserErrors[keyof ReactivateUserErrors];

export type ReactivateUserResponses = {
  /**
   * User was reactivated
   */
  200: SingleResponseForUser;
};

export type ReactivateUserResponse =
  ReactivateUserResponses[keyof ReactivateUserResponses];

export type LockUserData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/users/{id}/lock";
};

export type LockUserErrors = {
  /**
   * User ID not found
   */
  404: ErrorResponse;
};

export type LockUserError = LockUserErrors[keyof LockUserErrors];

export type LockUserResponses = {
  /**
   * User was locked
   */
  200: SingleResponseForUser;
};

export type LockUserResponse = LockUserResponses[keyof LockUserResponses];

export type UnlockUserData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/users/{id}/unlock";
};

export type UnlockUserErrors = {
  /**
   * User ID not found
   */
  404: ErrorResponse;
};

export type UnlockUserError = UnlockUserErrors[keyof UnlockUserErrors];

export type UnlockUserResponses = {
  /**
   * User was unlocked
   */
  200: SingleResponseForUser;
};

export type UnlockUserResponse = UnlockUserResponses[keyof UnlockUserResponses];

export type ListUserEmailsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Retrieve the items before the given ID
     */
    "page[before]"?: Ulid;
    /**
     * Retrieve the items after the given ID
     */
    "page[after]"?: Ulid;
    /**
     * Retrieve the first N items
     */
    "page[first]"?: number | null;
    /**
     * Retrieve the last N items
     */
    "page[last]"?: number | null;
    /**
     * Retrieve the items for the given user
     */
    "filter[user]"?: Ulid;
    /**
     * Retrieve the user email with the given email address
     */
    "filter[email]"?: string | null;
  };
  url: "/api/admin/v1/user-emails";
};

export type ListUserEmailsErrors = {
  /**
   * User was not found
   */
  404: ErrorResponse;
};

export type ListUserEmailsError =
  ListUserEmailsErrors[keyof ListUserEmailsErrors];

export type ListUserEmailsResponses = {
  /**
   * Paginated response of user emails
   */
  200: PaginatedResponseForUserEmail;
};

export type ListUserEmailsResponse =
  ListUserEmailsResponses[keyof ListUserEmailsResponses];

export type AddUserEmailData = {
  body: AddUserEmailRequest;
  path?: never;
  query?: never;
  url: "/api/admin/v1/user-emails";
};

export type AddUserEmailErrors = {
  /**
   * Email is not valid
   */
  400: ErrorResponse;
  /**
   * User was not found
   */
  404: ErrorResponse;
  /**
   * Email already in use
   */
  409: ErrorResponse;
};

export type AddUserEmailError = AddUserEmailErrors[keyof AddUserEmailErrors];

export type AddUserEmailResponses = {
  /**
   * User email was created
   */
  201: SingleResponseForUserEmail;
};

export type AddUserEmailResponse =
  AddUserEmailResponses[keyof AddUserEmailResponses];

export type DeleteUserEmailData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/user-emails/{id}";
};

export type DeleteUserEmailErrors = {
  /**
   * User email was not found
   */
  404: ErrorResponse;
};

export type DeleteUserEmailError =
  DeleteUserEmailErrors[keyof DeleteUserEmailErrors];

export type DeleteUserEmailResponses = {
  /**
   * User email was found
   */
  204: void;
};

export type DeleteUserEmailResponse =
  DeleteUserEmailResponses[keyof DeleteUserEmailResponses];

export type GetUserEmailData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/user-emails/{id}";
};

export type GetUserEmailErrors = {
  /**
   * User email was not found
   */
  404: ErrorResponse;
};

export type GetUserEmailError = GetUserEmailErrors[keyof GetUserEmailErrors];

export type GetUserEmailResponses = {
  /**
   * User email was found
   */
  200: SingleResponseForUserEmail;
};

export type GetUserEmailResponse =
  GetUserEmailResponses[keyof GetUserEmailResponses];

export type ListUserSessionsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Retrieve the items before the given ID
     */
    "page[before]"?: Ulid;
    /**
     * Retrieve the items after the given ID
     */
    "page[after]"?: Ulid;
    /**
     * Retrieve the first N items
     */
    "page[first]"?: number | null;
    /**
     * Retrieve the last N items
     */
    "page[last]"?: number | null;
    /**
     * Retrieve the items for the given user
     */
    "filter[user]"?: Ulid;
    /**
     * Retrieve the items with the given status
     *
     * Defaults to retrieve all sessions, including finished ones.
     *
     * * `active`: Only retrieve active sessions
     *
     * * `finished`: Only retrieve finished sessions
     */
    "filter[status]"?: UserSessionStatus;
  };
  url: "/api/admin/v1/user-sessions";
};

export type ListUserSessionsErrors = {
  /**
   * User was not found
   */
  404: ErrorResponse;
};

export type ListUserSessionsError =
  ListUserSessionsErrors[keyof ListUserSessionsErrors];

export type ListUserSessionsResponses = {
  /**
   * Paginated response of user sessions
   */
  200: PaginatedResponseForUserSession;
};

export type ListUserSessionsResponse =
  ListUserSessionsResponses[keyof ListUserSessionsResponses];

export type GetUserSessionData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/user-sessions/{id}";
};

export type GetUserSessionErrors = {
  /**
   * User session was not found
   */
  404: ErrorResponse;
};

export type GetUserSessionError =
  GetUserSessionErrors[keyof GetUserSessionErrors];

export type GetUserSessionResponses = {
  /**
   * User session was found
   */
  200: SingleResponseForUserSession;
};

export type GetUserSessionResponse =
  GetUserSessionResponses[keyof GetUserSessionResponses];

export type ListUserRegistrationTokensData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Retrieve the items before the given ID
     */
    "page[before]"?: Ulid;
    /**
     * Retrieve the items after the given ID
     */
    "page[after]"?: Ulid;
    /**
     * Retrieve the first N items
     */
    "page[first]"?: number | null;
    /**
     * Retrieve the last N items
     */
    "page[last]"?: number | null;
    /**
     * Retrieve tokens that have (or have not) been used at least once
     */
    "filter[used]"?: boolean | null;
    /**
     * Retrieve tokens that are (or are not) revoked
     */
    "filter[revoked]"?: boolean | null;
    /**
     * Retrieve tokens that are (or are not) expired
     */
    "filter[expired]"?: boolean | null;
    /**
     * Retrieve tokens that are (or are not) valid
     *
     * Valid means that the token has not expired, is not revoked, and has not reached its usage limit.
     */
    "filter[valid]"?: boolean | null;
  };
  url: "/api/admin/v1/user-registration-tokens";
};

export type ListUserRegistrationTokensResponses = {
  /**
   * Paginated response of registration tokens
   */
  200: PaginatedResponseForUserRegistrationToken;
};

export type ListUserRegistrationTokensResponse =
  ListUserRegistrationTokensResponses[keyof ListUserRegistrationTokensResponses];

export type AddUserRegistrationTokenData = {
  body: AddUserRegistrationTokenRequest;
  path?: never;
  query?: never;
  url: "/api/admin/v1/user-registration-tokens";
};

export type AddUserRegistrationTokenResponses = {
  /**
   * A new user registration token was created
   */
  201: SingleResponseForUserRegistrationToken;
};

export type AddUserRegistrationTokenResponse =
  AddUserRegistrationTokenResponses[keyof AddUserRegistrationTokenResponses];

export type GetUserRegistrationTokenData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/user-registration-tokens/{id}";
};

export type GetUserRegistrationTokenErrors = {
  /**
   * Registration token was not found
   */
  404: ErrorResponse;
};

export type GetUserRegistrationTokenError =
  GetUserRegistrationTokenErrors[keyof GetUserRegistrationTokenErrors];

export type GetUserRegistrationTokenResponses = {
  /**
   * Registration token was found
   */
  200: SingleResponseForUserRegistrationToken;
};

export type GetUserRegistrationTokenResponse =
  GetUserRegistrationTokenResponses[keyof GetUserRegistrationTokenResponses];

export type UpdateUserRegistrationTokenData = {
  body: EditUserRegistrationTokenRequest;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/user-registration-tokens/{id}";
};

export type UpdateUserRegistrationTokenErrors = {
  /**
   * Registration token was not found
   */
  404: ErrorResponse;
};

export type UpdateUserRegistrationTokenError =
  UpdateUserRegistrationTokenErrors[keyof UpdateUserRegistrationTokenErrors];

export type UpdateUserRegistrationTokenResponses = {
  /**
   * Registration token was updated
   */
  200: SingleResponseForUserRegistrationToken;
};

export type UpdateUserRegistrationTokenResponse =
  UpdateUserRegistrationTokenResponses[keyof UpdateUserRegistrationTokenResponses];

export type RevokeUserRegistrationTokenData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/user-registration-tokens/{id}/revoke";
};

export type RevokeUserRegistrationTokenErrors = {
  /**
   * Token is already revoked
   */
  400: ErrorResponse;
  /**
   * Registration token was not found
   */
  404: ErrorResponse;
};

export type RevokeUserRegistrationTokenError =
  RevokeUserRegistrationTokenErrors[keyof RevokeUserRegistrationTokenErrors];

export type RevokeUserRegistrationTokenResponses = {
  /**
   * Registration token was revoked
   */
  200: SingleResponseForUserRegistrationToken;
};

export type RevokeUserRegistrationTokenResponse =
  RevokeUserRegistrationTokenResponses[keyof RevokeUserRegistrationTokenResponses];

export type UnrevokeUserRegistrationTokenData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/user-registration-tokens/{id}/unrevoke";
};

export type UnrevokeUserRegistrationTokenErrors = {
  /**
   * Token is not revoked
   */
  400: ErrorResponse;
  /**
   * Registration token was not found
   */
  404: ErrorResponse;
};

export type UnrevokeUserRegistrationTokenError =
  UnrevokeUserRegistrationTokenErrors[keyof UnrevokeUserRegistrationTokenErrors];

export type UnrevokeUserRegistrationTokenResponses = {
  /**
   * Registration token was unrevoked
   */
  200: SingleResponseForUserRegistrationToken;
};

export type UnrevokeUserRegistrationTokenResponse =
  UnrevokeUserRegistrationTokenResponses[keyof UnrevokeUserRegistrationTokenResponses];

export type ListUpstreamOAuthLinksData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Retrieve the items before the given ID
     */
    "page[before]"?: Ulid;
    /**
     * Retrieve the items after the given ID
     */
    "page[after]"?: Ulid;
    /**
     * Retrieve the first N items
     */
    "page[first]"?: number | null;
    /**
     * Retrieve the last N items
     */
    "page[last]"?: number | null;
    /**
     * Retrieve the items for the given user
     */
    "filter[user]"?: Ulid;
    /**
     * Retrieve the items for the given provider
     */
    "filter[provider]"?: Ulid;
    /**
     * Retrieve the items with the given subject
     */
    "filter[subject]"?: string | null;
  };
  url: "/api/admin/v1/upstream-oauth-links";
};

export type ListUpstreamOAuthLinksErrors = {
  /**
   * User or provider was not found
   */
  404: ErrorResponse;
};

export type ListUpstreamOAuthLinksError =
  ListUpstreamOAuthLinksErrors[keyof ListUpstreamOAuthLinksErrors];

export type ListUpstreamOAuthLinksResponses = {
  /**
   * Paginated response of upstream OAuth 2.0 links
   */
  200: PaginatedResponseForUpstreamOAuthLink;
};

export type ListUpstreamOAuthLinksResponse =
  ListUpstreamOAuthLinksResponses[keyof ListUpstreamOAuthLinksResponses];

export type AddUpstreamOAuthLinkData = {
  body: AddUpstreamOauthLinkRequest;
  path?: never;
  query?: never;
  url: "/api/admin/v1/upstream-oauth-links";
};

export type AddUpstreamOAuthLinkErrors = {
  /**
   * User or provider was not found
   */
  404: ErrorResponse;
  /**
   * The subject from the provider is already linked to another user
   */
  409: ErrorResponse;
};

export type AddUpstreamOAuthLinkError =
  AddUpstreamOAuthLinkErrors[keyof AddUpstreamOAuthLinkErrors];

export type AddUpstreamOAuthLinkResponses = {
  /**
   * An existing Upstream OAuth 2.0 link was associated to a user
   */
  200: SingleResponseForUpstreamOAuthLink;
  /**
   * A new Upstream OAuth 2.0 link was created
   */
  201: SingleResponseForUpstreamOAuthLink;
};

export type AddUpstreamOAuthLinkResponse =
  AddUpstreamOAuthLinkResponses[keyof AddUpstreamOAuthLinkResponses];

export type DeleteUpstreamOAuthLinkData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/upstream-oauth-links/{id}";
};

export type DeleteUpstreamOAuthLinkErrors = {
  /**
   * Upstream OAuth 2.0 link was not found
   */
  404: ErrorResponse;
};

export type DeleteUpstreamOAuthLinkError =
  DeleteUpstreamOAuthLinkErrors[keyof DeleteUpstreamOAuthLinkErrors];

export type DeleteUpstreamOAuthLinkResponses = {
  /**
   * Upstream OAuth 2.0 link was deleted
   */
  204: void;
};

export type DeleteUpstreamOAuthLinkResponse =
  DeleteUpstreamOAuthLinkResponses[keyof DeleteUpstreamOAuthLinkResponses];

export type GetUpstreamOAuthLinkData = {
  body?: never;
  path: {
    id: Ulid;
  };
  query?: never;
  url: "/api/admin/v1/upstream-oauth-links/{id}";
};

export type GetUpstreamOAuthLinkErrors = {
  /**
   * Upstream OAuth 2.0 link was not found
   */
  404: ErrorResponse;
};

export type GetUpstreamOAuthLinkError =
  GetUpstreamOAuthLinkErrors[keyof GetUpstreamOAuthLinkErrors];

export type GetUpstreamOAuthLinkResponses = {
  /**
   * Upstream OAuth 2.0 link was found
   */
  200: SingleResponseForUpstreamOAuthLink;
};

export type GetUpstreamOAuthLinkResponse =
  GetUpstreamOAuthLinkResponses[keyof GetUpstreamOAuthLinkResponses];

export type ListUpstreamOAuthProvidersData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Retrieve the items before the given ID
     */
    "page[before]"?: Ulid;
    /**
     * Retrieve the items after the given ID
     */
    "page[after]"?: Ulid;
    /**
     * Retrieve the first N items
     */
    "page[first]"?: number | null;
    /**
     * Retrieve the last N items
     */
    "page[last]"?: number | null;
    /**
     * Retrieve providers that are (or are not) enabled
     */
    "filter[enabled]"?: boolean | null;
  };
  url: "/api/admin/v1/upstream-oauth-providers";
};

export type ListUpstreamOAuthProvidersResponses = {
  /**
   * Paginated response of upstream OAuth 2.0 providers
   */
  200: PaginatedResponseForUpstreamOAuthProvider;
};

export type ListUpstreamOAuthProvidersResponse =
  ListUpstreamOAuthProvidersResponses[keyof ListUpstreamOAuthProvidersResponses];

export type ClientOptions = {
  baseUrl: `${string}://{base}` | (string & {});
};
