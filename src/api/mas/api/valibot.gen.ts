// This file is auto-generated by @hey-api/openapi-ts

import * as v from "valibot";

export const vSiteConfig = v.object({
  server_name: v.string(),
  password_login_enabled: v.optional(v.boolean()),
  password_registration_enabled: v.optional(v.boolean()),
  password_registration_email_required: v.optional(v.boolean()),
  registration_token_required: v.optional(v.boolean()),
  email_change_allowed: v.optional(v.boolean()),
  displayname_change_allowed: v.optional(v.boolean()),
  password_change_allowed: v.optional(v.boolean()),
  account_recovery_allowed: v.optional(v.boolean()),
  account_deactivation_allowed: v.optional(v.boolean()),
  captcha_enabled: v.optional(v.boolean()),
  minimum_password_complexity: v.optional(
    v.pipe(
      v.number(),
      v.integer(),
      v.minValue(0, "Invalid value: Expected uint8 to be >= 0"),
      v.maxValue(255, "Invalid value: Expected uint8 to be <= 2^8-1"),
      v.minValue(0),
      v.maxValue(4),
    ),
  ),
});

export const vVersion = v.object({
  version: v.string(),
});

/**
 * ULID
 * A ULID as per https://github.com/ulid/spec
 */
export const vUlid = v.pipe(
  v.string(),
  v.regex(/^[0123456789ABCDEFGHJKMNPQRSTVWXYZ]{26}$/),
);

export const vIncludeCount = v.union([
  v.picklist(["true"]),
  v.picklist(["false"]),
  v.picklist(["only"]),
]);

export const vPaginationParams = v.object({
  "page[before]": v.optional(vUlid),
  "page[after]": v.optional(vUlid),
  "page[first]": v.optional(
    v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
  ),
  "page[last]": v.optional(
    v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
  ),
  count: v.optional(vIncludeCount),
});

export const vCompatSessionStatus = v.picklist(["active", "finished"]);

export const vCompatSessionFilter = v.object({
  "filter[user]": v.optional(vUlid),
  "filter[user-session]": v.optional(vUlid),
  "filter[status]": v.optional(vCompatSessionStatus),
});

export const vPaginationMeta = v.object({
  count: v.optional(
    v.union([v.pipe(v.number(), v.integer(), v.minValue(0)), v.null()]),
  ),
});

/**
 * Device ID
 */
export const vDeviceId = v.pipe(
  v.string(),
  v.regex(/^[A-Za-z0-9._~!$&'()*+,;=:&\/-]+$/),
);

/**
 * A compatibility session for legacy clients
 */
export const vCompatSession = v.object({
  user_id: vUlid,
  device_id: vDeviceId,
  user_session_id: vUlid,
  redirect_uri: v.optional(v.union([v.pipe(v.string(), v.url()), v.null()])),
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  user_agent: v.optional(v.union([v.string(), v.null()])),
  last_active_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  last_active_ip: v.optional(v.union([v.string(), v.null()])),
  finished_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  human_name: v.optional(v.union([v.string(), v.null()])),
});

/**
 * Related links
 */
export const vSelfLinks = v.object({
  self: v.string(),
});

/**
 * Pagination metadata for a resource
 */
export const vSingleResourceMetaPage = v.object({
  cursor: v.string(),
});

/**
 * Metadata associated with a resource
 */
export const vSingleResourceMeta = v.object({
  page: v.optional(vSingleResourceMetaPage),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForCompatSession = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vCompatSession,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * Related links
 */
export const vPaginationLinks = v.object({
  self: v.string(),
  first: v.optional(v.union([v.string(), v.null()])),
  last: v.optional(v.union([v.string(), v.null()])),
  next: v.optional(v.union([v.string(), v.null()])),
  prev: v.optional(v.union([v.string(), v.null()])),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForCompatSession = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(
    v.union([v.array(vSingleResourceForCompatSession), v.null()]),
  ),
  links: vPaginationLinks,
});

/**
 * A single error
 */
export const vError = v.object({
  title: v.string(),
});

/**
 * A top-level response with a list of errors
 */
export const vErrorResponse = v.object({
  errors: v.array(vError),
});

export const vUlidInPath = v.object({
  id: vUlid,
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForCompatSession = v.object({
  data: vSingleResourceForCompatSession,
  links: vSelfLinks,
});

export const vOAuth2ClientKind = v.picklist(["dynamic", "static"]);

export const vOAuth2SessionStatus = v.picklist(["active", "finished"]);

export const vOAuth2SessionFilter = v.object({
  "filter[user]": v.optional(vUlid),
  "filter[client]": v.optional(vUlid),
  "filter[client-kind]": v.optional(vOAuth2ClientKind),
  "filter[user-session]": v.optional(vUlid),
  "filter[scope]": v.optional(v.array(v.string()), []),
  "filter[status]": v.optional(vOAuth2SessionStatus),
});

/**
 * A OAuth 2.0 session
 */
export const vOAuth2Session = v.object({
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  finished_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  user_id: v.optional(vUlid),
  user_session_id: v.optional(vUlid),
  client_id: vUlid,
  scope: v.string(),
  user_agent: v.optional(v.union([v.string(), v.null()])),
  last_active_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  last_active_ip: v.optional(v.union([v.string(), v.null()])),
  human_name: v.optional(v.union([v.string(), v.null()])),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForOAuth2Session = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vOAuth2Session,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForOAuth2Session = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(
    v.union([v.array(vSingleResourceForOAuth2Session), v.null()]),
  ),
  links: vPaginationLinks,
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForOAuth2Session = v.object({
  data: vSingleResourceForOAuth2Session,
  links: vSelfLinks,
});

export const vPersonalSessionStatus = v.picklist(["active", "revoked"]);

export const vPersonalSessionFilter = v.object({
  "filter[owner_user]": v.optional(vUlid),
  "filter[owner_client]": v.optional(vUlid),
  "filter[actor_user]": v.optional(vUlid),
  "filter[scope]": v.optional(v.array(v.string()), []),
  "filter[status]": v.optional(vPersonalSessionStatus),
  "filter[expires_before]": v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  "filter[expires_after]": v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  "filter[expires]": v.optional(v.union([v.boolean(), v.null()])),
});

/**
 * A personal session (session using personal access tokens)
 */
export const vPersonalSession = v.object({
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  revoked_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  owner_user_id: v.optional(v.union([v.string(), v.null()])),
  owner_client_id: v.optional(v.union([v.string(), v.null()])),
  actor_user_id: vUlid,
  human_name: v.string(),
  scope: v.string(),
  last_active_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  last_active_ip: v.optional(v.union([v.string(), v.null()])),
  expires_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  access_token: v.optional(v.union([v.string(), v.null()])),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForPersonalSession = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vPersonalSession,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForPersonalSession = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(
    v.union([v.array(vSingleResourceForPersonalSession), v.null()]),
  ),
  links: vPaginationLinks,
});

/**
 * JSON payload for the `POST /api/admin/v1/personal-sessions` endpoint
 */
export const vCreatePersonalSessionRequest = v.object({
  actor_user_id: vUlid,
  human_name: v.string(),
  scope: v.string(),
  expires_in: v.optional(
    v.union([
      v.pipe(
        v.number(),
        v.integer(),
        v.minValue(0, "Invalid value: Expected uint32 to be >= 0"),
        v.maxValue(
          4294967295,
          "Invalid value: Expected uint32 to be <= 2^32-1",
        ),
        v.minValue(0),
      ),
      v.null(),
    ]),
  ),
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForPersonalSession = v.object({
  data: vSingleResourceForPersonalSession,
  links: vSelfLinks,
});

/**
 * JSON payload for the `POST /api/admin/v1/personal-sessions/{id}/regenerate` endpoint
 */
export const vRegeneratePersonalSessionRequest = v.object({
  expires_in: v.optional(
    v.union([
      v.pipe(
        v.number(),
        v.integer(),
        v.minValue(0, "Invalid value: Expected uint32 to be >= 0"),
        v.maxValue(
          4294967295,
          "Invalid value: Expected uint32 to be <= 2^32-1",
        ),
        v.minValue(0),
      ),
      v.null(),
    ]),
  ),
});

/**
 * JSON payload for the `POST /api/admin/v1/policy-data`
 */
export const vSetPolicyDataRequest = v.object({
  data: v.unknown(),
});

/**
 * The policy data
 */
export const vPolicyData = v.object({
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  data: v.unknown(),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForPolicyData = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vPolicyData,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForPolicyData = v.object({
  data: vSingleResourceForPolicyData,
  links: vSelfLinks,
});

export const vUserStatus = v.picklist(["active", "locked", "deactivated"]);

export const vUserFilter = v.object({
  "filter[admin]": v.optional(v.union([v.boolean(), v.null()])),
  "filter[legacy-guest]": v.optional(v.union([v.boolean(), v.null()])),
  "filter[search]": v.optional(v.union([v.string(), v.null()])),
  "filter[status]": v.optional(vUserStatus),
});

/**
 * A user
 */
export const vUser = v.object({
  username: v.string(),
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  locked_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  deactivated_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  admin: v.boolean(),
  legacy_guest: v.optional(v.boolean()),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForUser = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vUser,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForUser = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(v.union([v.array(vSingleResourceForUser), v.null()])),
  links: vPaginationLinks,
});

/**
 * JSON payload for the `POST /api/admin/v1/users` endpoint
 */
export const vAddUserRequest = v.object({
  username: v.string(),
  skip_homeserver_check: v.optional(v.boolean(), false),
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForUser = v.object({
  data: vSingleResourceForUser,
  links: vSelfLinks,
});

/**
 * JSON payload for the `POST /api/admin/v1/users/:id/set-password` endpoint
 */
export const vSetUserPasswordRequest = v.object({
  password: v.string(),
  skip_password_check: v.optional(v.union([v.boolean(), v.null()])),
});

export const vUsernamePathParam = v.object({
  username: v.string(),
});

/**
 * JSON payload for the `POST /api/admin/v1/users/:id/set-admin` endpoint
 */
export const vUserSetAdminRequest = v.object({
  admin: v.boolean(),
});

/**
 * JSON payload for the `POST /api/admin/v1/users/:id/deactivate` endpoint
 */
export const vDeactivateUserRequest = v.object({
  skip_erase: v.optional(v.boolean(), false),
});

export const vUserEmailFilter = v.object({
  "filter[user]": v.optional(vUlid),
  "filter[email]": v.optional(v.union([v.string(), v.null()])),
});

/**
 * An email address for a user
 */
export const vUserEmail = v.object({
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  user_id: vUlid,
  email: v.string(),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForUserEmail = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vUserEmail,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForUserEmail = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(v.union([v.array(vSingleResourceForUserEmail), v.null()])),
  links: vPaginationLinks,
});

/**
 * JSON payload for the `POST /api/admin/v1/user-emails`
 */
export const vAddUserEmailRequest = v.object({
  user_id: vUlid,
  email: v.pipe(v.string(), v.email()),
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForUserEmail = v.object({
  data: vSingleResourceForUserEmail,
  links: vSelfLinks,
});

export const vUserSessionStatus = v.picklist(["active", "finished"]);

export const vUserSessionFilter = v.object({
  "filter[user]": v.optional(vUlid),
  "filter[status]": v.optional(vUserSessionStatus),
});

/**
 * The browser (cookie) session for a user
 */
export const vUserSession = v.object({
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  finished_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  user_id: vUlid,
  user_agent: v.optional(v.union([v.string(), v.null()])),
  last_active_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  last_active_ip: v.optional(v.union([v.string(), v.null()])),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForUserSession = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vUserSession,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForUserSession = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(v.union([v.array(vSingleResourceForUserSession), v.null()])),
  links: vPaginationLinks,
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForUserSession = v.object({
  data: vSingleResourceForUserSession,
  links: vSelfLinks,
});

export const vRegistrationTokenFilter = v.object({
  "filter[used]": v.optional(v.union([v.boolean(), v.null()])),
  "filter[revoked]": v.optional(v.union([v.boolean(), v.null()])),
  "filter[expired]": v.optional(v.union([v.boolean(), v.null()])),
  "filter[valid]": v.optional(v.union([v.boolean(), v.null()])),
});

/**
 * A registration token
 */
export const vUserRegistrationToken = v.object({
  token: v.string(),
  valid: v.boolean(),
  usage_limit: v.optional(
    v.union([
      v.pipe(
        v.number(),
        v.integer(),
        v.minValue(0, "Invalid value: Expected uint32 to be >= 0"),
        v.maxValue(
          4294967295,
          "Invalid value: Expected uint32 to be <= 2^32-1",
        ),
        v.minValue(0),
      ),
      v.null(),
    ]),
  ),
  times_used: v.pipe(
    v.number(),
    v.integer(),
    v.minValue(0, "Invalid value: Expected uint32 to be >= 0"),
    v.maxValue(4294967295, "Invalid value: Expected uint32 to be <= 2^32-1"),
    v.minValue(0),
  ),
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  last_used_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  expires_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  revoked_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForUserRegistrationToken = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vUserRegistrationToken,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForUserRegistrationToken = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(
    v.union([v.array(vSingleResourceForUserRegistrationToken), v.null()]),
  ),
  links: vPaginationLinks,
});

/**
 * JSON payload for the `POST /api/admin/v1/user-registration-tokens`
 */
export const vAddUserRegistrationTokenRequest = v.object({
  token: v.optional(v.union([v.string(), v.null()])),
  usage_limit: v.optional(
    v.union([
      v.pipe(
        v.number(),
        v.integer(),
        v.minValue(0, "Invalid value: Expected uint32 to be >= 0"),
        v.maxValue(
          4294967295,
          "Invalid value: Expected uint32 to be <= 2^32-1",
        ),
        v.minValue(0),
      ),
      v.null(),
    ]),
  ),
  expires_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForUserRegistrationToken = v.object({
  data: vSingleResourceForUserRegistrationToken,
  links: vSelfLinks,
});

/**
 * JSON payload for the `PUT /api/admin/v1/user-registration-tokens/{id}` endpoint
 */
export const vEditUserRegistrationTokenRequest = v.object({
  expires_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
  usage_limit: v.optional(
    v.union([
      v.pipe(
        v.number(),
        v.integer(),
        v.minValue(0, "Invalid value: Expected uint32 to be >= 0"),
        v.maxValue(
          4294967295,
          "Invalid value: Expected uint32 to be <= 2^32-1",
        ),
        v.minValue(0),
      ),
      v.null(),
    ]),
  ),
});

export const vUpstreamOAuthLinkFilter = v.object({
  "filter[user]": v.optional(vUlid),
  "filter[provider]": v.optional(vUlid),
  "filter[subject]": v.optional(v.union([v.string(), v.null()])),
});

/**
 * An upstream OAuth 2.0 link
 */
export const vUpstreamOAuthLink = v.object({
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  provider_id: vUlid,
  subject: v.string(),
  user_id: v.optional(vUlid),
  human_account_name: v.optional(v.union([v.string(), v.null()])),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForUpstreamOAuthLink = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vUpstreamOAuthLink,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForUpstreamOAuthLink = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(
    v.union([v.array(vSingleResourceForUpstreamOAuthLink), v.null()]),
  ),
  links: vPaginationLinks,
});

/**
 * JSON payload for the `POST /api/admin/v1/upstream-oauth-links`
 */
export const vAddUpstreamOauthLinkRequest = v.object({
  user_id: vUlid,
  provider_id: vUlid,
  subject: v.string(),
  human_account_name: v.optional(v.union([v.string(), v.null()])),
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForUpstreamOAuthLink = v.object({
  data: vSingleResourceForUpstreamOAuthLink,
  links: vSelfLinks,
});

export const vUpstreamOAuthProviderFilter = v.object({
  "filter[enabled]": v.optional(v.union([v.boolean(), v.null()])),
});

/**
 * An upstream OAuth 2.0 provider
 */
export const vUpstreamOAuthProvider = v.object({
  issuer: v.optional(v.union([v.string(), v.null()])),
  human_name: v.optional(v.union([v.string(), v.null()])),
  brand_name: v.optional(v.union([v.string(), v.null()])),
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  disabled_at: v.optional(
    v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
  ),
});

/**
 * A single resource, with its type, ID, attributes and related links
 */
export const vSingleResourceForUpstreamOAuthProvider = v.object({
  type: v.string(),
  id: vUlid,
  attributes: vUpstreamOAuthProvider,
  links: vSelfLinks,
  meta: v.optional(vSingleResourceMeta),
});

/**
 * A top-level response with a page of resources
 */
export const vPaginatedResponseForUpstreamOAuthProvider = v.object({
  meta: v.optional(vPaginationMeta),
  data: v.optional(
    v.union([v.array(vSingleResourceForUpstreamOAuthProvider), v.null()]),
  ),
  links: vPaginationLinks,
});

/**
 * A top-level response with a single resource
 */
export const vSingleResponseForUpstreamOAuthProvider = v.object({
  data: vSingleResourceForUpstreamOAuthProvider,
  links: vSelfLinks,
});

export const vSiteConfigData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

export const vSiteConfigResponse = vSiteConfig;

export const vVersionData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

export const vVersionResponse = vVersion;

export const vListCompatSessionsData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[user]": v.optional(vUlid),
      "filter[user-session]": v.optional(vUlid),
      "filter[status]": v.optional(vCompatSessionStatus),
    }),
  ),
});

/**
 * Paginated response of compatibility sessions
 */
export const vListCompatSessionsResponse = vPaginatedResponseForCompatSession;

export const vGetCompatSessionData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Compatibility session was found
 */
export const vGetCompatSessionResponse = vSingleResponseForCompatSession;

export const vFinishCompatSessionData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Compatibility session was finished
 */
export const vFinishCompatSessionResponse = vSingleResponseForCompatSession;

export const vListOAuth2SessionsData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[user]": v.optional(vUlid),
      "filter[client]": v.optional(vUlid),
      "filter[client-kind]": v.optional(vOAuth2ClientKind),
      "filter[user-session]": v.optional(vUlid),
      "filter[scope]": v.optional(v.array(v.string()), []),
      "filter[status]": v.optional(vOAuth2SessionStatus),
    }),
  ),
});

/**
 * Paginated response of OAuth 2.0 sessions
 */
export const vListOAuth2SessionsResponse = vPaginatedResponseForOAuth2Session;

export const vGetOAuth2SessionData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * OAuth 2.0 session was found
 */
export const vGetOAuth2SessionResponse = vSingleResponseForOAuth2Session;

export const vFinishOAuth2SessionData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * OAuth 2.0 session was finished
 */
export const vFinishOAuth2SessionResponse = vSingleResponseForOAuth2Session;

export const vListPersonalSessionsData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[owner_user]": v.optional(vUlid),
      "filter[owner_client]": v.optional(vUlid),
      "filter[actor_user]": v.optional(vUlid),
      "filter[scope]": v.optional(v.array(v.string()), []),
      "filter[status]": v.optional(vPersonalSessionStatus),
      "filter[expires_before]": v.optional(
        v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
      ),
      "filter[expires_after]": v.optional(
        v.union([v.pipe(v.string(), v.isoTimestamp()), v.null()]),
      ),
      "filter[expires]": v.optional(v.union([v.boolean(), v.null()])),
    }),
  ),
});

/**
 * Paginated response of personal sessions
 */
export const vListPersonalSessionsResponse =
  vPaginatedResponseForPersonalSession;

export const vCreatePersonalSessionData = v.object({
  body: vCreatePersonalSessionRequest,
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

/**
 * Personal session and personal access token were created
 */
export const vCreatePersonalSessionResponse = vSingleResponseForPersonalSession;

export const vGetPersonalSessionData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Personal session details
 */
export const vGetPersonalSessionResponse = vSingleResponseForPersonalSession;

export const vRevokePersonalSessionData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Personal session was revoked
 */
export const vRevokePersonalSessionResponse = vSingleResponseForPersonalSession;

export const vRegeneratePersonalSessionData = v.object({
  body: vRegeneratePersonalSessionRequest,
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Personal session was regenerated and a personal access token was created
 */
export const vRegeneratePersonalSessionResponse =
  vSingleResponseForPersonalSession;

export const vSetPolicyDataData = v.object({
  body: vSetPolicyDataRequest,
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

/**
 * Policy data was successfully set
 */
export const vSetPolicyDataResponse = vSingleResponseForPolicyData;

export const vGetLatestPolicyDataData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

/**
 * Latest policy data was found
 */
export const vGetLatestPolicyDataResponse = vSingleResponseForPolicyData;

export const vGetPolicyDataData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Policy data was found
 */
export const vGetPolicyDataResponse = vSingleResponseForPolicyData;

export const vListUsersData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[admin]": v.optional(v.union([v.boolean(), v.null()])),
      "filter[legacy-guest]": v.optional(v.union([v.boolean(), v.null()])),
      "filter[search]": v.optional(v.union([v.string(), v.null()])),
      "filter[status]": v.optional(vUserStatus),
    }),
  ),
});

/**
 * Paginated response of users
 */
export const vListUsersResponse = vPaginatedResponseForUser;

export const vCreateUserData = v.object({
  body: vAddUserRequest,
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

/**
 * User was created
 */
export const vCreateUserResponse = vSingleResponseForUser;

export const vGetUserData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User was found
 */
export const vGetUserResponse = vSingleResponseForUser;

export const vSetUserPasswordData = v.object({
  body: vSetUserPasswordRequest,
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Password was set
 */
export const vSetUserPasswordResponse = v.void();

export const vGetUserByUsernameData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    username: v.string(),
  }),
  query: v.optional(v.never()),
});

/**
 * User was found
 */
export const vGetUserByUsernameResponse = vSingleResponseForUser;

export const vUserSetAdminData = v.object({
  body: vUserSetAdminRequest,
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User had admin privileges set
 */
export const vUserSetAdminResponse = vSingleResponseForUser;

export const vDeactivateUserData = v.object({
  body: v.optional(vDeactivateUserRequest),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User was deactivated
 */
export const vDeactivateUserResponse = vSingleResponseForUser;

export const vReactivateUserData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User was reactivated
 */
export const vReactivateUserResponse = vSingleResponseForUser;

export const vLockUserData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User was locked
 */
export const vLockUserResponse = vSingleResponseForUser;

export const vUnlockUserData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User was unlocked
 */
export const vUnlockUserResponse = vSingleResponseForUser;

export const vListUserEmailsData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[user]": v.optional(vUlid),
      "filter[email]": v.optional(v.union([v.string(), v.null()])),
    }),
  ),
});

/**
 * Paginated response of user emails
 */
export const vListUserEmailsResponse = vPaginatedResponseForUserEmail;

export const vAddUserEmailData = v.object({
  body: vAddUserEmailRequest,
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

/**
 * User email was created
 */
export const vAddUserEmailResponse = vSingleResponseForUserEmail;

export const vDeleteUserEmailData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User email was found
 */
export const vDeleteUserEmailResponse = v.void();

export const vGetUserEmailData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User email was found
 */
export const vGetUserEmailResponse = vSingleResponseForUserEmail;

export const vListUserSessionsData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[user]": v.optional(vUlid),
      "filter[status]": v.optional(vUserSessionStatus),
    }),
  ),
});

/**
 * Paginated response of user sessions
 */
export const vListUserSessionsResponse = vPaginatedResponseForUserSession;

export const vGetUserSessionData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User session was found
 */
export const vGetUserSessionResponse = vSingleResponseForUserSession;

export const vFinishUserSessionData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * User session was finished
 */
export const vFinishUserSessionResponse = vSingleResponseForUserSession;

export const vListUserRegistrationTokensData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[used]": v.optional(v.union([v.boolean(), v.null()])),
      "filter[revoked]": v.optional(v.union([v.boolean(), v.null()])),
      "filter[expired]": v.optional(v.union([v.boolean(), v.null()])),
      "filter[valid]": v.optional(v.union([v.boolean(), v.null()])),
    }),
  ),
});

/**
 * Paginated response of registration tokens
 */
export const vListUserRegistrationTokensResponse =
  vPaginatedResponseForUserRegistrationToken;

export const vAddUserRegistrationTokenData = v.object({
  body: vAddUserRegistrationTokenRequest,
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

/**
 * A new user registration token was created
 */
export const vAddUserRegistrationTokenResponse =
  vSingleResponseForUserRegistrationToken;

export const vGetUserRegistrationTokenData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Registration token was found
 */
export const vGetUserRegistrationTokenResponse =
  vSingleResponseForUserRegistrationToken;

export const vUpdateUserRegistrationTokenData = v.object({
  body: vEditUserRegistrationTokenRequest,
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Registration token was updated
 */
export const vUpdateUserRegistrationTokenResponse =
  vSingleResponseForUserRegistrationToken;

export const vRevokeUserRegistrationTokenData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Registration token was revoked
 */
export const vRevokeUserRegistrationTokenResponse =
  vSingleResponseForUserRegistrationToken;

export const vUnrevokeUserRegistrationTokenData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Registration token was unrevoked
 */
export const vUnrevokeUserRegistrationTokenResponse =
  vSingleResponseForUserRegistrationToken;

export const vListUpstreamOAuthLinksData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[user]": v.optional(vUlid),
      "filter[provider]": v.optional(vUlid),
      "filter[subject]": v.optional(v.union([v.string(), v.null()])),
    }),
  ),
});

/**
 * Paginated response of upstream OAuth 2.0 links
 */
export const vListUpstreamOAuthLinksResponse =
  vPaginatedResponseForUpstreamOAuthLink;

export const vAddUpstreamOAuthLinkData = v.object({
  body: vAddUpstreamOauthLinkRequest,
  path: v.optional(v.never()),
  query: v.optional(v.never()),
});

/**
 * An existing Upstream OAuth 2.0 link was associated to a user
 */
export const vAddUpstreamOAuthLinkResponse =
  vSingleResponseForUpstreamOAuthLink;

export const vDeleteUpstreamOAuthLinkData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Upstream OAuth 2.0 link was deleted
 */
export const vDeleteUpstreamOAuthLinkResponse = v.void();

export const vGetUpstreamOAuthLinkData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * Upstream OAuth 2.0 link was found
 */
export const vGetUpstreamOAuthLinkResponse =
  vSingleResponseForUpstreamOAuthLink;

export const vListUpstreamOAuthProvidersData = v.object({
  body: v.optional(v.never()),
  path: v.optional(v.never()),
  query: v.optional(
    v.object({
      "page[before]": v.optional(vUlid),
      "page[after]": v.optional(vUlid),
      "page[first]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      "page[last]": v.optional(
        v.union([v.pipe(v.number(), v.integer(), v.minValue(1)), v.null()]),
      ),
      count: v.optional(vIncludeCount),
      "filter[enabled]": v.optional(v.union([v.boolean(), v.null()])),
    }),
  ),
});

/**
 * Paginated response of upstream OAuth 2.0 providers
 */
export const vListUpstreamOAuthProvidersResponse =
  vPaginatedResponseForUpstreamOAuthProvider;

export const vGetUpstreamOAuthProviderData = v.object({
  body: v.optional(v.never()),
  path: v.object({
    id: vUlid,
  }),
  query: v.optional(v.never()),
});

/**
 * The upstream OAuth provider
 */
export const vGetUpstreamOAuthProviderResponse =
  vSingleResponseForUpstreamOAuthProvider;
