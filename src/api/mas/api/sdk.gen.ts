// This file is auto-generated by @hey-api/openapi-ts

import * as v from "valibot";

import type { Options as ClientOptions, Client, TDataShape } from "./client";
import type {
  ListCompatSessionsData,
  ListCompatSessionsResponses,
  ListCompatSessionsErrors,
  GetCompatSessionData,
  GetCompatSessionResponses,
  GetCompatSessionErrors,
  ListOAuth2SessionsData,
  ListOAuth2SessionsResponses,
  ListOAuth2SessionsErrors,
  GetOAuth2SessionData,
  GetOAuth2SessionResponses,
  GetOAuth2SessionErrors,
  SetPolicyDataData,
  SetPolicyDataResponses,
  SetPolicyDataErrors,
  GetLatestPolicyDataData,
  GetLatestPolicyDataResponses,
  GetLatestPolicyDataErrors,
  GetPolicyDataData,
  GetPolicyDataResponses,
  GetPolicyDataErrors,
  ListUsersData,
  ListUsersResponses,
  CreateUserData,
  CreateUserResponses,
  CreateUserErrors,
  GetUserData,
  GetUserResponses,
  GetUserErrors,
  SetUserPasswordData,
  SetUserPasswordResponses,
  SetUserPasswordErrors,
  GetUserByUsernameData,
  GetUserByUsernameResponses,
  GetUserByUsernameErrors,
  UserSetAdminData,
  UserSetAdminResponses,
  UserSetAdminErrors,
  DeactivateUserData,
  DeactivateUserResponses,
  DeactivateUserErrors,
  ReactivateUserData,
  ReactivateUserResponses,
  ReactivateUserErrors,
  LockUserData,
  LockUserResponses,
  LockUserErrors,
  UnlockUserData,
  UnlockUserResponses,
  UnlockUserErrors,
  ListUserEmailsData,
  ListUserEmailsResponses,
  ListUserEmailsErrors,
  AddUserEmailData,
  AddUserEmailResponses,
  AddUserEmailErrors,
  DeleteUserEmailData,
  DeleteUserEmailResponses,
  DeleteUserEmailErrors,
  GetUserEmailData,
  GetUserEmailResponses,
  GetUserEmailErrors,
  ListUserSessionsData,
  ListUserSessionsResponses,
  ListUserSessionsErrors,
  GetUserSessionData,
  GetUserSessionResponses,
  GetUserSessionErrors,
  ListUserRegistrationTokensData,
  ListUserRegistrationTokensResponses,
  AddUserRegistrationTokenData,
  AddUserRegistrationTokenResponses,
  GetUserRegistrationTokenData,
  GetUserRegistrationTokenResponses,
  GetUserRegistrationTokenErrors,
  UpdateUserRegistrationTokenData,
  UpdateUserRegistrationTokenResponses,
  UpdateUserRegistrationTokenErrors,
  RevokeUserRegistrationTokenData,
  RevokeUserRegistrationTokenResponses,
  RevokeUserRegistrationTokenErrors,
  UnrevokeUserRegistrationTokenData,
  UnrevokeUserRegistrationTokenResponses,
  UnrevokeUserRegistrationTokenErrors,
  ListUpstreamOAuthLinksData,
  ListUpstreamOAuthLinksResponses,
  ListUpstreamOAuthLinksErrors,
  AddUpstreamOAuthLinkData,
  AddUpstreamOAuthLinkResponses,
  AddUpstreamOAuthLinkErrors,
  DeleteUpstreamOAuthLinkData,
  DeleteUpstreamOAuthLinkResponses,
  DeleteUpstreamOAuthLinkErrors,
  GetUpstreamOAuthLinkData,
  GetUpstreamOAuthLinkResponses,
  GetUpstreamOAuthLinkErrors,
} from "./types.gen";
import {
  vListCompatSessionsData,
  vListCompatSessionsResponse,
  vGetCompatSessionData,
  vGetCompatSessionResponse,
  vListOAuth2SessionsData,
  vListOAuth2SessionsResponse,
  vGetOAuth2SessionData,
  vGetOAuth2SessionResponse,
  vSetPolicyDataData,
  vSetPolicyDataResponse,
  vGetLatestPolicyDataData,
  vGetLatestPolicyDataResponse,
  vGetPolicyDataData,
  vGetPolicyDataResponse,
  vListUsersData,
  vListUsersResponse,
  vCreateUserData,
  vCreateUserResponse,
  vGetUserData,
  vGetUserResponse,
  vSetUserPasswordData,
  vSetUserPasswordResponse,
  vGetUserByUsernameData,
  vGetUserByUsernameResponse,
  vUserSetAdminData,
  vUserSetAdminResponse,
  vDeactivateUserData,
  vDeactivateUserResponse,
  vReactivateUserData,
  vReactivateUserResponse,
  vLockUserData,
  vLockUserResponse,
  vUnlockUserData,
  vUnlockUserResponse,
  vListUserEmailsData,
  vListUserEmailsResponse,
  vAddUserEmailData,
  vAddUserEmailResponse,
  vDeleteUserEmailData,
  vDeleteUserEmailResponse,
  vGetUserEmailData,
  vGetUserEmailResponse,
  vListUserSessionsData,
  vListUserSessionsResponse,
  vGetUserSessionData,
  vGetUserSessionResponse,
  vListUserRegistrationTokensData,
  vListUserRegistrationTokensResponse,
  vAddUserRegistrationTokenData,
  vAddUserRegistrationTokenResponse,
  vGetUserRegistrationTokenData,
  vGetUserRegistrationTokenResponse,
  vUpdateUserRegistrationTokenData,
  vUpdateUserRegistrationTokenResponse,
  vRevokeUserRegistrationTokenData,
  vRevokeUserRegistrationTokenResponse,
  vUnrevokeUserRegistrationTokenData,
  vUnrevokeUserRegistrationTokenResponse,
  vListUpstreamOAuthLinksData,
  vListUpstreamOAuthLinksResponse,
  vAddUpstreamOAuthLinkData,
  vAddUpstreamOAuthLinkResponse,
  vDeleteUpstreamOAuthLinkData,
  vDeleteUpstreamOAuthLinkResponse,
  vGetUpstreamOAuthLinkData,
  vGetUpstreamOAuthLinkResponse,
} from "./valibot.gen";

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = ClientOptions<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client: Client;
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>;
};

/**
 * List compatibility sessions
 * Retrieve a list of compatibility sessions.
 * Note that by default, all sessions, including finished ones are returned, with the oldest first.
 * Use the `filter[status]` parameter to filter the sessions by their status and `page[last]` parameter to retrieve the last N sessions.
 */
export const listCompatSessions = <ThrowOnError extends boolean = true>(
  options: Options<ListCompatSessionsData, ThrowOnError>,
) => {
  return options.client.get<
    ListCompatSessionsResponses,
    ListCompatSessionsErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListCompatSessionsData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListCompatSessionsResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/compat-sessions",
    ...options,
  });
};

/**
 * Get a compatibility session
 */
export const getCompatSession = <ThrowOnError extends boolean = true>(
  options: Options<GetCompatSessionData, ThrowOnError>,
) => {
  return options.client.get<
    GetCompatSessionResponses,
    GetCompatSessionErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetCompatSessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetCompatSessionResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/compat-sessions/{id}",
    ...options,
  });
};

/**
 * List OAuth 2.0 sessions
 * Retrieve a list of OAuth 2.0 sessions.
 * Note that by default, all sessions, including finished ones are returned, with the oldest first.
 * Use the `filter[status]` parameter to filter the sessions by their status and `page[last]` parameter to retrieve the last N sessions.
 */
export const listOAuth2Sessions = <ThrowOnError extends boolean = true>(
  options: Options<ListOAuth2SessionsData, ThrowOnError>,
) => {
  return options.client.get<
    ListOAuth2SessionsResponses,
    ListOAuth2SessionsErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListOAuth2SessionsData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListOAuth2SessionsResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/oauth2-sessions",
    ...options,
  });
};

/**
 * Get an OAuth 2.0 session
 */
export const getOAuth2Session = <ThrowOnError extends boolean = true>(
  options: Options<GetOAuth2SessionData, ThrowOnError>,
) => {
  return options.client.get<
    GetOAuth2SessionResponses,
    GetOAuth2SessionErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetOAuth2SessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetOAuth2SessionResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/oauth2-sessions/{id}",
    ...options,
  });
};

/**
 * Set the current policy data
 */
export const setPolicyData = <ThrowOnError extends boolean = true>(
  options: Options<SetPolicyDataData, ThrowOnError>,
) => {
  return options.client.post<
    SetPolicyDataResponses,
    SetPolicyDataErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vSetPolicyDataData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vSetPolicyDataResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/policy-data",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get the latest policy data
 */
export const getLatestPolicyData = <ThrowOnError extends boolean = true>(
  options: Options<GetLatestPolicyDataData, ThrowOnError>,
) => {
  return options.client.get<
    GetLatestPolicyDataResponses,
    GetLatestPolicyDataErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetLatestPolicyDataData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetLatestPolicyDataResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/policy-data/latest",
    ...options,
  });
};

/**
 * Get policy data by ID
 */
export const getPolicyData = <ThrowOnError extends boolean = true>(
  options: Options<GetPolicyDataData, ThrowOnError>,
) => {
  return options.client.get<
    GetPolicyDataResponses,
    GetPolicyDataErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetPolicyDataData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetPolicyDataResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/policy-data/{id}",
    ...options,
  });
};

/**
 * List users
 */
export const listUsers = <ThrowOnError extends boolean = true>(
  options: Options<ListUsersData, ThrowOnError>,
) => {
  return options.client.get<ListUsersResponses, unknown, ThrowOnError, "data">({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUsersData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUsersResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users",
    ...options,
  });
};

/**
 * Create a new user
 */
export const createUser = <ThrowOnError extends boolean = true>(
  options: Options<CreateUserData, ThrowOnError>,
) => {
  return options.client.post<
    CreateUserResponses,
    CreateUserErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vCreateUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vCreateUserResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get a user
 */
export const getUser = <ThrowOnError extends boolean = true>(
  options: Options<GetUserData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserResponses,
    GetUserErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}",
    ...options,
  });
};

/**
 * Set the password for a user
 */
export const setUserPassword = <ThrowOnError extends boolean = true>(
  options: Options<SetUserPasswordData, ThrowOnError>,
) => {
  return options.client.post<
    SetUserPasswordResponses,
    SetUserPasswordErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vSetUserPasswordData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vSetUserPasswordResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/set-password",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get a user by its username (localpart)
 */
export const getUserByUsername = <ThrowOnError extends boolean = true>(
  options: Options<GetUserByUsernameData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserByUsernameResponses,
    GetUserByUsernameErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserByUsernameData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserByUsernameResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/by-username/{username}",
    ...options,
  });
};

/**
 * Set whether a user can request admin
 * Calling this endpoint will not have any effect on existing sessions, meaning that their existing sessions will keep admin access if they were granted it.
 */
export const userSetAdmin = <ThrowOnError extends boolean = true>(
  options: Options<UserSetAdminData, ThrowOnError>,
) => {
  return options.client.post<
    UserSetAdminResponses,
    UserSetAdminErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vUserSetAdminData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vUserSetAdminResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/set-admin",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Deactivate a user
 * Calling this endpoint will deactivate the user, preventing them from doing any action.
 * This invalidates any existing session, and will ask the homeserver to make them leave all rooms.
 */
export const deactivateUser = <ThrowOnError extends boolean = true>(
  options: Options<DeactivateUserData, ThrowOnError>,
) => {
  return options.client.post<
    DeactivateUserResponses,
    DeactivateUserErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vDeactivateUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vDeactivateUserResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/deactivate",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Reactivate a user
 * Calling this endpoint will reactivate a deactivated user.
 * This DOES NOT unlock a locked user, which is still prevented from doing any action until it is explicitly unlocked.
 */
export const reactivateUser = <ThrowOnError extends boolean = true>(
  options: Options<ReactivateUserData, ThrowOnError>,
) => {
  return options.client.post<
    ReactivateUserResponses,
    ReactivateUserErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vReactivateUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vReactivateUserResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/reactivate",
    ...options,
  });
};

/**
 * Lock a user
 * Calling this endpoint will lock the user, preventing them from doing any action.
 * This DOES NOT invalidate any existing session, meaning that all their existing sessions will work again as soon as they get unlocked.
 */
export const lockUser = <ThrowOnError extends boolean = true>(
  options: Options<LockUserData, ThrowOnError>,
) => {
  return options.client.post<
    LockUserResponses,
    LockUserErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vLockUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vLockUserResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/lock",
    ...options,
  });
};

/**
 * Unlock a user
 * Calling this endpoint will lift restrictions on user actions that had imposed by locking.
 * This DOES NOT reactivate a deactivated user, which will remain unavailable until it is explicitly reactivated.
 */
export const unlockUser = <ThrowOnError extends boolean = true>(
  options: Options<UnlockUserData, ThrowOnError>,
) => {
  return options.client.post<
    UnlockUserResponses,
    UnlockUserErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vUnlockUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vUnlockUserResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/unlock",
    ...options,
  });
};

/**
 * List user emails
 * Retrieve a list of user emails.
 */
export const listUserEmails = <ThrowOnError extends boolean = true>(
  options: Options<ListUserEmailsData, ThrowOnError>,
) => {
  return options.client.get<
    ListUserEmailsResponses,
    ListUserEmailsErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUserEmailsData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUserEmailsResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-emails",
    ...options,
  });
};

/**
 * Add a user email
 * Add an email address to a user.
 * Note that this endpoint ignores any policy which would normally prevent the email from being added.
 */
export const addUserEmail = <ThrowOnError extends boolean = true>(
  options: Options<AddUserEmailData, ThrowOnError>,
) => {
  return options.client.post<
    AddUserEmailResponses,
    AddUserEmailErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vAddUserEmailData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vAddUserEmailResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-emails",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Delete a user email
 */
export const deleteUserEmail = <ThrowOnError extends boolean = true>(
  options: Options<DeleteUserEmailData, ThrowOnError>,
) => {
  return options.client.delete<
    DeleteUserEmailResponses,
    DeleteUserEmailErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vDeleteUserEmailData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vDeleteUserEmailResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-emails/{id}",
    ...options,
  });
};

/**
 * Get a user email
 */
export const getUserEmail = <ThrowOnError extends boolean = true>(
  options: Options<GetUserEmailData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserEmailResponses,
    GetUserEmailErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserEmailData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserEmailResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-emails/{id}",
    ...options,
  });
};

/**
 * List user sessions
 * Retrieve a list of user sessions (browser sessions).
 * Note that by default, all sessions, including finished ones are returned, with the oldest first.
 * Use the `filter[status]` parameter to filter the sessions by their status and `page[last]` parameter to retrieve the last N sessions.
 */
export const listUserSessions = <ThrowOnError extends boolean = true>(
  options: Options<ListUserSessionsData, ThrowOnError>,
) => {
  return options.client.get<
    ListUserSessionsResponses,
    ListUserSessionsErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUserSessionsData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUserSessionsResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-sessions",
    ...options,
  });
};

/**
 * Get a user session
 */
export const getUserSession = <ThrowOnError extends boolean = true>(
  options: Options<GetUserSessionData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserSessionResponses,
    GetUserSessionErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserSessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserSessionResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-sessions/{id}",
    ...options,
  });
};

/**
 * List user registration tokens
 */
export const listUserRegistrationTokens = <ThrowOnError extends boolean = true>(
  options: Options<ListUserRegistrationTokensData, ThrowOnError>,
) => {
  return options.client.get<
    ListUserRegistrationTokensResponses,
    unknown,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUserRegistrationTokensData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUserRegistrationTokensResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens",
    ...options,
  });
};

/**
 * Create a new user registration token
 */
export const addUserRegistrationToken = <ThrowOnError extends boolean = true>(
  options: Options<AddUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.post<
    AddUserRegistrationTokenResponses,
    unknown,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vAddUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vAddUserRegistrationTokenResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get a user registration token
 */
export const getUserRegistrationToken = <ThrowOnError extends boolean = true>(
  options: Options<GetUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserRegistrationTokenResponses,
    GetUserRegistrationTokenErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserRegistrationTokenResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens/{id}",
    ...options,
  });
};

/**
 * Update a user registration token
 * Update properties of a user registration token such as expiration and usage limit. To set a field to null (removing the limit/expiration), include the field with a null value. To leave a field unchanged, omit it from the request body.
 */
export const updateUserRegistrationToken = <
  ThrowOnError extends boolean = true,
>(
  options: Options<UpdateUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.put<
    UpdateUserRegistrationTokenResponses,
    UpdateUserRegistrationTokenErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vUpdateUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vUpdateUserRegistrationTokenResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens/{id}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Revoke a user registration token
 * Calling this endpoint will revoke the user registration token, preventing it from being used for new registrations.
 */
export const revokeUserRegistrationToken = <
  ThrowOnError extends boolean = true,
>(
  options: Options<RevokeUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.post<
    RevokeUserRegistrationTokenResponses,
    RevokeUserRegistrationTokenErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vRevokeUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vRevokeUserRegistrationTokenResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens/{id}/revoke",
    ...options,
  });
};

/**
 * Unrevoke a user registration token
 * Calling this endpoint will unrevoke a previously revoked user registration token, allowing it to be used for registrations again (subject to its usage limits and expiration).
 */
export const unrevokeUserRegistrationToken = <
  ThrowOnError extends boolean = true,
>(
  options: Options<UnrevokeUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.post<
    UnrevokeUserRegistrationTokenResponses,
    UnrevokeUserRegistrationTokenErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vUnrevokeUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vUnrevokeUserRegistrationTokenResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens/{id}/unrevoke",
    ...options,
  });
};

/**
 * List upstream OAuth 2.0 links
 * Retrieve a list of upstream OAuth 2.0 links.
 */
export const listUpstreamOAuthLinks = <ThrowOnError extends boolean = true>(
  options: Options<ListUpstreamOAuthLinksData, ThrowOnError>,
) => {
  return options.client.get<
    ListUpstreamOAuthLinksResponses,
    ListUpstreamOAuthLinksErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUpstreamOAuthLinksData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUpstreamOAuthLinksResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-links",
    ...options,
  });
};

/**
 * Add an upstream OAuth 2.0 link
 */
export const addUpstreamOAuthLink = <ThrowOnError extends boolean = true>(
  options: Options<AddUpstreamOAuthLinkData, ThrowOnError>,
) => {
  return options.client.post<
    AddUpstreamOAuthLinkResponses,
    AddUpstreamOAuthLinkErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vAddUpstreamOAuthLinkData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vAddUpstreamOAuthLinkResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-links",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Delete an upstream OAuth 2.0 link
 */
export const deleteUpstreamOAuthLink = <ThrowOnError extends boolean = true>(
  options: Options<DeleteUpstreamOAuthLinkData, ThrowOnError>,
) => {
  return options.client.delete<
    DeleteUpstreamOAuthLinkResponses,
    DeleteUpstreamOAuthLinkErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vDeleteUpstreamOAuthLinkData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vDeleteUpstreamOAuthLinkResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-links/{id}",
    ...options,
  });
};

/**
 * Get an upstream OAuth 2.0 link
 */
export const getUpstreamOAuthLink = <ThrowOnError extends boolean = true>(
  options: Options<GetUpstreamOAuthLinkData, ThrowOnError>,
) => {
  return options.client.get<
    GetUpstreamOAuthLinkResponses,
    GetUpstreamOAuthLinkErrors,
    ThrowOnError,
    "data"
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUpstreamOAuthLinkData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUpstreamOAuthLinkResponse, data);
    },
    responseStyle: "data",
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-links/{id}",
    ...options,
  });
};
