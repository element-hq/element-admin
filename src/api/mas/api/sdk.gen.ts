// This file is auto-generated by @hey-api/openapi-ts

import * as v from "valibot";

import type { Client, Options as Options2, TDataShape } from "./client";
import type {
  AddUpstreamOAuthLinkData,
  AddUpstreamOAuthLinkErrors,
  AddUpstreamOAuthLinkResponses,
  AddUserEmailData,
  AddUserEmailErrors,
  AddUserEmailResponses,
  AddUserRegistrationTokenData,
  AddUserRegistrationTokenResponses,
  CreateUserData,
  CreateUserErrors,
  CreateUserResponses,
  DeactivateUserData,
  DeactivateUserErrors,
  DeactivateUserResponses,
  DeleteUpstreamOAuthLinkData,
  DeleteUpstreamOAuthLinkErrors,
  DeleteUpstreamOAuthLinkResponses,
  DeleteUserEmailData,
  DeleteUserEmailErrors,
  DeleteUserEmailResponses,
  FinishCompatSessionData,
  FinishCompatSessionErrors,
  FinishCompatSessionResponses,
  FinishOAuth2SessionData,
  FinishOAuth2SessionErrors,
  FinishOAuth2SessionResponses,
  FinishUserSessionData,
  FinishUserSessionErrors,
  FinishUserSessionResponses,
  GetCompatSessionData,
  GetCompatSessionErrors,
  GetCompatSessionResponses,
  GetLatestPolicyDataData,
  GetLatestPolicyDataErrors,
  GetLatestPolicyDataResponses,
  GetOAuth2SessionData,
  GetOAuth2SessionErrors,
  GetOAuth2SessionResponses,
  GetPolicyDataData,
  GetPolicyDataErrors,
  GetPolicyDataResponses,
  GetUpstreamOAuthLinkData,
  GetUpstreamOAuthLinkErrors,
  GetUpstreamOAuthLinkResponses,
  GetUpstreamOAuthProviderData,
  GetUpstreamOAuthProviderErrors,
  GetUpstreamOAuthProviderResponses,
  GetUserByUsernameData,
  GetUserByUsernameErrors,
  GetUserByUsernameResponses,
  GetUserData,
  GetUserEmailData,
  GetUserEmailErrors,
  GetUserEmailResponses,
  GetUserErrors,
  GetUserRegistrationTokenData,
  GetUserRegistrationTokenErrors,
  GetUserRegistrationTokenResponses,
  GetUserResponses,
  GetUserSessionData,
  GetUserSessionErrors,
  GetUserSessionResponses,
  ListCompatSessionsData,
  ListCompatSessionsErrors,
  ListCompatSessionsResponses,
  ListOAuth2SessionsData,
  ListOAuth2SessionsErrors,
  ListOAuth2SessionsResponses,
  ListUpstreamOAuthLinksData,
  ListUpstreamOAuthLinksErrors,
  ListUpstreamOAuthLinksResponses,
  ListUpstreamOAuthProvidersData,
  ListUpstreamOAuthProvidersResponses,
  ListUserEmailsData,
  ListUserEmailsErrors,
  ListUserEmailsResponses,
  ListUserRegistrationTokensData,
  ListUserRegistrationTokensResponses,
  ListUsersData,
  ListUserSessionsData,
  ListUserSessionsErrors,
  ListUserSessionsResponses,
  ListUsersResponses,
  LockUserData,
  LockUserErrors,
  LockUserResponses,
  ReactivateUserData,
  ReactivateUserErrors,
  ReactivateUserResponses,
  RevokeUserRegistrationTokenData,
  RevokeUserRegistrationTokenErrors,
  RevokeUserRegistrationTokenResponses,
  SetPolicyDataData,
  SetPolicyDataErrors,
  SetPolicyDataResponses,
  SetUserPasswordData,
  SetUserPasswordErrors,
  SetUserPasswordResponses,
  SiteConfigData,
  SiteConfigResponses,
  UnlockUserData,
  UnlockUserErrors,
  UnlockUserResponses,
  UnrevokeUserRegistrationTokenData,
  UnrevokeUserRegistrationTokenErrors,
  UnrevokeUserRegistrationTokenResponses,
  UpdateUserRegistrationTokenData,
  UpdateUserRegistrationTokenErrors,
  UpdateUserRegistrationTokenResponses,
  UserSetAdminData,
  UserSetAdminErrors,
  UserSetAdminResponses,
  VersionData,
  VersionResponses,
} from "./types.gen";
import {
  vAddUpstreamOAuthLinkData,
  vAddUpstreamOAuthLinkResponse,
  vAddUserEmailData,
  vAddUserEmailResponse,
  vAddUserRegistrationTokenData,
  vAddUserRegistrationTokenResponse,
  vCreateUserData,
  vCreateUserResponse,
  vDeactivateUserData,
  vDeactivateUserResponse,
  vDeleteUpstreamOAuthLinkData,
  vDeleteUpstreamOAuthLinkResponse,
  vDeleteUserEmailData,
  vDeleteUserEmailResponse,
  vFinishCompatSessionData,
  vFinishCompatSessionResponse,
  vFinishOAuth2SessionData,
  vFinishOAuth2SessionResponse,
  vFinishUserSessionData,
  vFinishUserSessionResponse,
  vGetCompatSessionData,
  vGetCompatSessionResponse,
  vGetLatestPolicyDataData,
  vGetLatestPolicyDataResponse,
  vGetOAuth2SessionData,
  vGetOAuth2SessionResponse,
  vGetPolicyDataData,
  vGetPolicyDataResponse,
  vGetUpstreamOAuthLinkData,
  vGetUpstreamOAuthLinkResponse,
  vGetUpstreamOAuthProviderData,
  vGetUpstreamOAuthProviderResponse,
  vGetUserByUsernameData,
  vGetUserByUsernameResponse,
  vGetUserData,
  vGetUserEmailData,
  vGetUserEmailResponse,
  vGetUserRegistrationTokenData,
  vGetUserRegistrationTokenResponse,
  vGetUserResponse,
  vGetUserSessionData,
  vGetUserSessionResponse,
  vListCompatSessionsData,
  vListCompatSessionsResponse,
  vListOAuth2SessionsData,
  vListOAuth2SessionsResponse,
  vListUpstreamOAuthLinksData,
  vListUpstreamOAuthLinksResponse,
  vListUpstreamOAuthProvidersData,
  vListUpstreamOAuthProvidersResponse,
  vListUserEmailsData,
  vListUserEmailsResponse,
  vListUserRegistrationTokensData,
  vListUserRegistrationTokensResponse,
  vListUsersData,
  vListUserSessionsData,
  vListUserSessionsResponse,
  vListUsersResponse,
  vLockUserData,
  vLockUserResponse,
  vReactivateUserData,
  vReactivateUserResponse,
  vRevokeUserRegistrationTokenData,
  vRevokeUserRegistrationTokenResponse,
  vSetPolicyDataData,
  vSetPolicyDataResponse,
  vSetUserPasswordData,
  vSetUserPasswordResponse,
  vSiteConfigData,
  vSiteConfigResponse,
  vUnlockUserData,
  vUnlockUserResponse,
  vUnrevokeUserRegistrationTokenData,
  vUnrevokeUserRegistrationTokenResponse,
  vUpdateUserRegistrationTokenData,
  vUpdateUserRegistrationTokenResponse,
  vUserSetAdminData,
  vUserSetAdminResponse,
  vVersionData,
  vVersionResponse,
} from "./valibot.gen";

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client: Client;
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>;
};

/**
 * Get informations about the configuration of this MAS instance
 */
export const siteConfig = <ThrowOnError extends boolean = false>(
  options: Options<SiteConfigData, ThrowOnError>,
) => {
  return options.client.get<SiteConfigResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => {
      return await v.parseAsync(vSiteConfigData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vSiteConfigResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/site-config",
    ...options,
  });
};

/**
 * Get the version currently running
 */
export const version = <ThrowOnError extends boolean = false>(
  options: Options<VersionData, ThrowOnError>,
) => {
  return options.client.get<VersionResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => {
      return await v.parseAsync(vVersionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vVersionResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/version",
    ...options,
  });
};

/**
 * List compatibility sessions
 * Retrieve a list of compatibility sessions.
 * Note that by default, all sessions, including finished ones are returned, with the oldest first.
 * Use the `filter[status]` parameter to filter the sessions by their status and `page[last]` parameter to retrieve the last N sessions.
 */
export const listCompatSessions = <ThrowOnError extends boolean = false>(
  options: Options<ListCompatSessionsData, ThrowOnError>,
) => {
  return options.client.get<
    ListCompatSessionsResponses,
    ListCompatSessionsErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListCompatSessionsData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListCompatSessionsResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/compat-sessions",
    ...options,
  });
};

/**
 * Get a compatibility session
 */
export const getCompatSession = <ThrowOnError extends boolean = false>(
  options: Options<GetCompatSessionData, ThrowOnError>,
) => {
  return options.client.get<
    GetCompatSessionResponses,
    GetCompatSessionErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetCompatSessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetCompatSessionResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/compat-sessions/{id}",
    ...options,
  });
};

/**
 * Finish a compatibility session
 * Calling this endpoint will finish the compatibility session, preventing any further use. A job will be scheduled to sync the user's devices with the homeserver.
 */
export const finishCompatSession = <ThrowOnError extends boolean = false>(
  options: Options<FinishCompatSessionData, ThrowOnError>,
) => {
  return options.client.post<
    FinishCompatSessionResponses,
    FinishCompatSessionErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vFinishCompatSessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vFinishCompatSessionResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/compat-sessions/{id}/finish",
    ...options,
  });
};

/**
 * List OAuth 2.0 sessions
 * Retrieve a list of OAuth 2.0 sessions.
 * Note that by default, all sessions, including finished ones are returned, with the oldest first.
 * Use the `filter[status]` parameter to filter the sessions by their status and `page[last]` parameter to retrieve the last N sessions.
 */
export const listOAuth2Sessions = <ThrowOnError extends boolean = false>(
  options: Options<ListOAuth2SessionsData, ThrowOnError>,
) => {
  return options.client.get<
    ListOAuth2SessionsResponses,
    ListOAuth2SessionsErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListOAuth2SessionsData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListOAuth2SessionsResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/oauth2-sessions",
    ...options,
  });
};

/**
 * Get an OAuth 2.0 session
 */
export const getOAuth2Session = <ThrowOnError extends boolean = false>(
  options: Options<GetOAuth2SessionData, ThrowOnError>,
) => {
  return options.client.get<
    GetOAuth2SessionResponses,
    GetOAuth2SessionErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetOAuth2SessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetOAuth2SessionResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/oauth2-sessions/{id}",
    ...options,
  });
};

/**
 * Finish an OAuth 2.0 session
 * Calling this endpoint will finish the OAuth 2.0 session, preventing any further use. If the session has a user associated with it, a job will be scheduled to sync the user's devices with the homeserver.
 */
export const finishOAuth2Session = <ThrowOnError extends boolean = false>(
  options: Options<FinishOAuth2SessionData, ThrowOnError>,
) => {
  return options.client.post<
    FinishOAuth2SessionResponses,
    FinishOAuth2SessionErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vFinishOAuth2SessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vFinishOAuth2SessionResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/oauth2-sessions/{id}/finish",
    ...options,
  });
};

/**
 * Set the current policy data
 */
export const setPolicyData = <ThrowOnError extends boolean = false>(
  options: Options<SetPolicyDataData, ThrowOnError>,
) => {
  return options.client.post<
    SetPolicyDataResponses,
    SetPolicyDataErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vSetPolicyDataData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vSetPolicyDataResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/policy-data",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get the latest policy data
 */
export const getLatestPolicyData = <ThrowOnError extends boolean = false>(
  options: Options<GetLatestPolicyDataData, ThrowOnError>,
) => {
  return options.client.get<
    GetLatestPolicyDataResponses,
    GetLatestPolicyDataErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetLatestPolicyDataData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetLatestPolicyDataResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/policy-data/latest",
    ...options,
  });
};

/**
 * Get policy data by ID
 */
export const getPolicyData = <ThrowOnError extends boolean = false>(
  options: Options<GetPolicyDataData, ThrowOnError>,
) => {
  return options.client.get<
    GetPolicyDataResponses,
    GetPolicyDataErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetPolicyDataData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetPolicyDataResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/policy-data/{id}",
    ...options,
  });
};

/**
 * List users
 */
export const listUsers = <ThrowOnError extends boolean = false>(
  options: Options<ListUsersData, ThrowOnError>,
) => {
  return options.client.get<ListUsersResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUsersData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUsersResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users",
    ...options,
  });
};

/**
 * Create a new user
 */
export const createUser = <ThrowOnError extends boolean = false>(
  options: Options<CreateUserData, ThrowOnError>,
) => {
  return options.client.post<
    CreateUserResponses,
    CreateUserErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vCreateUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vCreateUserResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get a user
 */
export const getUser = <ThrowOnError extends boolean = false>(
  options: Options<GetUserData, ThrowOnError>,
) => {
  return options.client.get<GetUserResponses, GetUserErrors, ThrowOnError>({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}",
    ...options,
  });
};

/**
 * Set the password for a user
 */
export const setUserPassword = <ThrowOnError extends boolean = false>(
  options: Options<SetUserPasswordData, ThrowOnError>,
) => {
  return options.client.post<
    SetUserPasswordResponses,
    SetUserPasswordErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vSetUserPasswordData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vSetUserPasswordResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/set-password",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get a user by its username (localpart)
 */
export const getUserByUsername = <ThrowOnError extends boolean = false>(
  options: Options<GetUserByUsernameData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserByUsernameResponses,
    GetUserByUsernameErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserByUsernameData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserByUsernameResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/by-username/{username}",
    ...options,
  });
};

/**
 * Set whether a user can request admin
 * Calling this endpoint will not have any effect on existing sessions, meaning that their existing sessions will keep admin access if they were granted it.
 */
export const userSetAdmin = <ThrowOnError extends boolean = false>(
  options: Options<UserSetAdminData, ThrowOnError>,
) => {
  return options.client.post<
    UserSetAdminResponses,
    UserSetAdminErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vUserSetAdminData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vUserSetAdminResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/set-admin",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Deactivate a user
 * Calling this endpoint will deactivate the user, preventing them from doing any action.
 * This invalidates any existing session, and will ask the homeserver to make them leave all rooms.
 */
export const deactivateUser = <ThrowOnError extends boolean = false>(
  options: Options<DeactivateUserData, ThrowOnError>,
) => {
  return options.client.post<
    DeactivateUserResponses,
    DeactivateUserErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vDeactivateUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vDeactivateUserResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/deactivate",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Reactivate a user
 * Calling this endpoint will reactivate a deactivated user.
 * This DOES NOT unlock a locked user, which is still prevented from doing any action until it is explicitly unlocked.
 */
export const reactivateUser = <ThrowOnError extends boolean = false>(
  options: Options<ReactivateUserData, ThrowOnError>,
) => {
  return options.client.post<
    ReactivateUserResponses,
    ReactivateUserErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vReactivateUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vReactivateUserResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/reactivate",
    ...options,
  });
};

/**
 * Lock a user
 * Calling this endpoint will lock the user, preventing them from doing any action.
 * This DOES NOT invalidate any existing session, meaning that all their existing sessions will work again as soon as they get unlocked.
 */
export const lockUser = <ThrowOnError extends boolean = false>(
  options: Options<LockUserData, ThrowOnError>,
) => {
  return options.client.post<LockUserResponses, LockUserErrors, ThrowOnError>({
    requestValidator: async (data) => {
      return await v.parseAsync(vLockUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vLockUserResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/lock",
    ...options,
  });
};

/**
 * Unlock a user
 * Calling this endpoint will lift restrictions on user actions that had imposed by locking.
 * This DOES NOT reactivate a deactivated user, which will remain unavailable until it is explicitly reactivated.
 */
export const unlockUser = <ThrowOnError extends boolean = false>(
  options: Options<UnlockUserData, ThrowOnError>,
) => {
  return options.client.post<
    UnlockUserResponses,
    UnlockUserErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vUnlockUserData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vUnlockUserResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/users/{id}/unlock",
    ...options,
  });
};

/**
 * List user emails
 * Retrieve a list of user emails.
 */
export const listUserEmails = <ThrowOnError extends boolean = false>(
  options: Options<ListUserEmailsData, ThrowOnError>,
) => {
  return options.client.get<
    ListUserEmailsResponses,
    ListUserEmailsErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUserEmailsData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUserEmailsResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-emails",
    ...options,
  });
};

/**
 * Add a user email
 * Add an email address to a user.
 * Note that this endpoint ignores any policy which would normally prevent the email from being added.
 */
export const addUserEmail = <ThrowOnError extends boolean = false>(
  options: Options<AddUserEmailData, ThrowOnError>,
) => {
  return options.client.post<
    AddUserEmailResponses,
    AddUserEmailErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vAddUserEmailData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vAddUserEmailResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-emails",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Delete a user email
 */
export const deleteUserEmail = <ThrowOnError extends boolean = false>(
  options: Options<DeleteUserEmailData, ThrowOnError>,
) => {
  return options.client.delete<
    DeleteUserEmailResponses,
    DeleteUserEmailErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vDeleteUserEmailData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vDeleteUserEmailResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-emails/{id}",
    ...options,
  });
};

/**
 * Get a user email
 */
export const getUserEmail = <ThrowOnError extends boolean = false>(
  options: Options<GetUserEmailData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserEmailResponses,
    GetUserEmailErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserEmailData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserEmailResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-emails/{id}",
    ...options,
  });
};

/**
 * List user sessions
 * Retrieve a list of user sessions (browser sessions).
 * Note that by default, all sessions, including finished ones are returned, with the oldest first.
 * Use the `filter[status]` parameter to filter the sessions by their status and `page[last]` parameter to retrieve the last N sessions.
 */
export const listUserSessions = <ThrowOnError extends boolean = false>(
  options: Options<ListUserSessionsData, ThrowOnError>,
) => {
  return options.client.get<
    ListUserSessionsResponses,
    ListUserSessionsErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUserSessionsData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUserSessionsResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-sessions",
    ...options,
  });
};

/**
 * Get a user session
 */
export const getUserSession = <ThrowOnError extends boolean = false>(
  options: Options<GetUserSessionData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserSessionResponses,
    GetUserSessionErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserSessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserSessionResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-sessions/{id}",
    ...options,
  });
};

/**
 * Finish a user session
 * Calling this endpoint will finish the user session, preventing any further use.
 */
export const finishUserSession = <ThrowOnError extends boolean = false>(
  options: Options<FinishUserSessionData, ThrowOnError>,
) => {
  return options.client.post<
    FinishUserSessionResponses,
    FinishUserSessionErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vFinishUserSessionData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vFinishUserSessionResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-sessions/{id}/finish",
    ...options,
  });
};

/**
 * List user registration tokens
 */
export const listUserRegistrationTokens = <
  ThrowOnError extends boolean = false,
>(
  options: Options<ListUserRegistrationTokensData, ThrowOnError>,
) => {
  return options.client.get<
    ListUserRegistrationTokensResponses,
    unknown,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUserRegistrationTokensData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUserRegistrationTokensResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens",
    ...options,
  });
};

/**
 * Create a new user registration token
 */
export const addUserRegistrationToken = <ThrowOnError extends boolean = false>(
  options: Options<AddUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.post<
    AddUserRegistrationTokenResponses,
    unknown,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vAddUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vAddUserRegistrationTokenResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get a user registration token
 */
export const getUserRegistrationToken = <ThrowOnError extends boolean = false>(
  options: Options<GetUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.get<
    GetUserRegistrationTokenResponses,
    GetUserRegistrationTokenErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUserRegistrationTokenResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens/{id}",
    ...options,
  });
};

/**
 * Update a user registration token
 * Update properties of a user registration token such as expiration and usage limit. To set a field to null (removing the limit/expiration), include the field with a null value. To leave a field unchanged, omit it from the request body.
 */
export const updateUserRegistrationToken = <
  ThrowOnError extends boolean = false,
>(
  options: Options<UpdateUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.put<
    UpdateUserRegistrationTokenResponses,
    UpdateUserRegistrationTokenErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vUpdateUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vUpdateUserRegistrationTokenResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens/{id}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Revoke a user registration token
 * Calling this endpoint will revoke the user registration token, preventing it from being used for new registrations.
 */
export const revokeUserRegistrationToken = <
  ThrowOnError extends boolean = false,
>(
  options: Options<RevokeUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.post<
    RevokeUserRegistrationTokenResponses,
    RevokeUserRegistrationTokenErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vRevokeUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vRevokeUserRegistrationTokenResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens/{id}/revoke",
    ...options,
  });
};

/**
 * Unrevoke a user registration token
 * Calling this endpoint will unrevoke a previously revoked user registration token, allowing it to be used for registrations again (subject to its usage limits and expiration).
 */
export const unrevokeUserRegistrationToken = <
  ThrowOnError extends boolean = false,
>(
  options: Options<UnrevokeUserRegistrationTokenData, ThrowOnError>,
) => {
  return options.client.post<
    UnrevokeUserRegistrationTokenResponses,
    UnrevokeUserRegistrationTokenErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vUnrevokeUserRegistrationTokenData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vUnrevokeUserRegistrationTokenResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/user-registration-tokens/{id}/unrevoke",
    ...options,
  });
};

/**
 * List upstream OAuth 2.0 links
 * Retrieve a list of upstream OAuth 2.0 links.
 */
export const listUpstreamOAuthLinks = <ThrowOnError extends boolean = false>(
  options: Options<ListUpstreamOAuthLinksData, ThrowOnError>,
) => {
  return options.client.get<
    ListUpstreamOAuthLinksResponses,
    ListUpstreamOAuthLinksErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUpstreamOAuthLinksData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUpstreamOAuthLinksResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-links",
    ...options,
  });
};

/**
 * Add an upstream OAuth 2.0 link
 */
export const addUpstreamOAuthLink = <ThrowOnError extends boolean = false>(
  options: Options<AddUpstreamOAuthLinkData, ThrowOnError>,
) => {
  return options.client.post<
    AddUpstreamOAuthLinkResponses,
    AddUpstreamOAuthLinkErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vAddUpstreamOAuthLinkData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vAddUpstreamOAuthLinkResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-links",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Delete an upstream OAuth 2.0 link
 */
export const deleteUpstreamOAuthLink = <ThrowOnError extends boolean = false>(
  options: Options<DeleteUpstreamOAuthLinkData, ThrowOnError>,
) => {
  return options.client.delete<
    DeleteUpstreamOAuthLinkResponses,
    DeleteUpstreamOAuthLinkErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vDeleteUpstreamOAuthLinkData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vDeleteUpstreamOAuthLinkResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-links/{id}",
    ...options,
  });
};

/**
 * Get an upstream OAuth 2.0 link
 */
export const getUpstreamOAuthLink = <ThrowOnError extends boolean = false>(
  options: Options<GetUpstreamOAuthLinkData, ThrowOnError>,
) => {
  return options.client.get<
    GetUpstreamOAuthLinkResponses,
    GetUpstreamOAuthLinkErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUpstreamOAuthLinkData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUpstreamOAuthLinkResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-links/{id}",
    ...options,
  });
};

/**
 * List upstream OAuth 2.0 providers
 */
export const listUpstreamOAuthProviders = <
  ThrowOnError extends boolean = false,
>(
  options: Options<ListUpstreamOAuthProvidersData, ThrowOnError>,
) => {
  return options.client.get<
    ListUpstreamOAuthProvidersResponses,
    unknown,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vListUpstreamOAuthProvidersData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vListUpstreamOAuthProvidersResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-providers",
    ...options,
  });
};

/**
 * Get upstream OAuth provider
 */
export const getUpstreamOAuthProvider = <ThrowOnError extends boolean = false>(
  options: Options<GetUpstreamOAuthProviderData, ThrowOnError>,
) => {
  return options.client.get<
    GetUpstreamOAuthProviderResponses,
    GetUpstreamOAuthProviderErrors,
    ThrowOnError
  >({
    requestValidator: async (data) => {
      return await v.parseAsync(vGetUpstreamOAuthProviderData, data);
    },
    responseValidator: async (data) => {
      return await v.parseAsync(vGetUpstreamOAuthProviderResponse, data);
    },
    security: [
      {
        scheme: "bearer",
        type: "http",
      },
    ],
    url: "/api/admin/v1/upstream-oauth-providers/{id}",
    ...options,
  });
};
